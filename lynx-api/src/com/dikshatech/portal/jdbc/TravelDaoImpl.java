/*
 * This source file was generated by FireStorm/DAO.
 * 
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * 
 * For more information please visit http://www.codefutures.com/products/firestorm
 */

package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;

import org.apache.log4j.Logger;

import com.dikshatech.beans.TravelRequest;
import com.dikshatech.common.utils.PortalUtility;
import com.dikshatech.portal.dao.TravelDao;
import com.dikshatech.portal.dto.Travel;
import com.dikshatech.portal.dto.TravelPk;
import com.dikshatech.portal.exceptions.TravelDaoException;
import com.dikshatech.portal.forms.TravelForm;

public class TravelDaoImpl extends AbstractDAO implements TravelDao {
	/**
	 * The factory class for this DAO has two versions of the create() method -
	 * one that takes no arguments and one that takes a Connection argument. If
	 * the Connection version is chosen then the connection will be stored in
	 * this attribute and will be used by all calls to this DAO, otherwise a new
	 * Connection will be allocated for each operation.
	 */
	protected java.sql.Connection userConn;

	protected static final Logger logger = Logger
			.getLogger(TravelDaoImpl.class);

	/**
	 * All finder methods in this class use this SELECT constant to build their
	 * queries
	 */
	protected final String SQL_SELECT = "SELECT ID, ESRQM_ID, STATUS, RAISED_BY, IS_CONTACT_PERSON_REQ, TL_TYPE, TRL_USER_ID, PURPOSE_OF_TL, TRAVELLER_COMMENTS, SPOUSE_NAME, IS_ROLL_ON, CHARGE_CODE, MODE_OF_TL, TL_FROM, TL_TO, PRF_DATE_TO_TL, PRF_TIME_TO_TL, IS_ROUND_TRIP, RETURN_DATE, RETURN_TIME, ACCOMODATION_REQ, TYPE_OF_ACCOMODATION, CAB_REQ, ONWARD_INWARD, CREATE_DATE, DOCUMENTS_ID FROM "
			+ getTableName() + "";

	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int maxRows;

	/**
	 * SQL INSERT statement for this table
	 */
	protected final String SQL_INSERT = "INSERT INTO "
			+ getTableName()
			+ " ( ID, ESRQM_ID, STATUS, RAISED_BY, IS_CONTACT_PERSON_REQ, TL_TYPE, TRL_USER_ID, PURPOSE_OF_TL, TRAVELLER_COMMENTS, SPOUSE_NAME, IS_ROLL_ON, CHARGE_CODE, MODE_OF_TL, TL_FROM, TL_TO, PRF_DATE_TO_TL, PRF_TIME_TO_TL, IS_ROUND_TRIP, RETURN_DATE, RETURN_TIME, ACCOMODATION_REQ, TYPE_OF_ACCOMODATION, CAB_REQ, ONWARD_INWARD, CREATE_DATE, DOCUMENTS_ID ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String SQL_UPDATE = "UPDATE "
			+ getTableName()
			+ " SET ID = ?, ESRQM_ID = ?, STATUS = ?, RAISED_BY = ?, IS_CONTACT_PERSON_REQ = ?, TL_TYPE = ?, TRL_USER_ID = ?, PURPOSE_OF_TL = ?, TRAVELLER_COMMENTS = ?, SPOUSE_NAME = ?, IS_ROLL_ON = ?, CHARGE_CODE = ?, MODE_OF_TL = ?, TL_FROM = ?, TL_TO = ?, PRF_DATE_TO_TL = ?, PRF_TIME_TO_TL = ?, IS_ROUND_TRIP = ?, RETURN_DATE = ?, RETURN_TIME = ?, ACCOMODATION_REQ = ?, TYPE_OF_ACCOMODATION = ?, CAB_REQ = ?, ONWARD_INWARD = ?, CREATE_DATE = ?, DOCUMENTS_ID = ? WHERE ID = ?";

	/**
	 * SQL DELETE statement for this table
	 */
	protected final String SQL_DELETE = "DELETE FROM " + getTableName()
			+ " WHERE ID = ?";

	protected static int INDEX = 1;

	/**
	 * Index of column ID
	 */
	protected static final int COLUMN_ID = 1;

	/**
	 * Index of column ESRQM_ID
	 */
	protected static final int COLUMN_ESRQM_ID = 2;

	/**
	 * Index of column STATUS
	 */
	protected static final int COLUMN_STATUS = 3;

	/**
	 * Index of column RAISED_BY
	 */
	protected static final int COLUMN_RAISED_BY = 4;

	/**
	 * Index of column IS_CONTACT_PERSON_REQ
	 */
	protected static final int COLUMN_IS_CONTACT_PERSON_REQ = 5;

	/**
	 * Index of column TL_TYPE
	 */
	protected static final int COLUMN_TL_TYPE = 6;

	/**
	 * Index of column TRL_USER_ID
	 */
	protected static final int COLUMN_TRL_USER_ID = 7;

	/**
	 * Index of column PURPOSE_OF_TL
	 */
	protected static final int COLUMN_PURPOSE_OF_TL = 8;

	/**
	 * Index of column TRAVELLER_COMMENTS
	 */
	protected static final int COLUMN_TRAVELLER_COMMENTS = 9;

	/**
	 * Index of column SPOUSE_NAME
	 */
	protected static final int COLUMN_SPOUSE_NAME = 10;

	/**
	 * Index of column IS_ROLL_ON
	 */
	protected static final int COLUMN_IS_ROLL_ON = 11;

	/**
	 * Index of column CHARGE_CODE
	 */
	protected static final int COLUMN_CHARGE_CODE = 12;

	/**
	 * Index of column MODE_OF_TL
	 */
	protected static final int COLUMN_MODE_OF_TL = 13;

	/**
	 * Index of column TL_FROM
	 */
	protected static final int COLUMN_TL_FROM = 14;

	/**
	 * Index of column TL_TO
	 */
	protected static final int COLUMN_TL_TO = 15;

	/**
	 * Index of column PRF_DATE_TO_TL
	 */
	protected static final int COLUMN_PRF_DATE_TO_TL = 16;

	/**
	 * Index of column PRF_TIME_TO_TL
	 */
	protected static final int COLUMN_PRF_TIME_TO_TL = 17;

	/**
	 * Index of column IS_ROUND_TRIP
	 */
	protected static final int COLUMN_IS_ROUND_TRIP = 18;

	/**
	 * Index of column RETURN_DATE
	 */
	protected static final int COLUMN_RETURN_DATE = 19;

	/**
	 * Index of column RETURN_TIME
	 */
	protected static final int COLUMN_RETURN_TIME = 20;

	/**
	 * Index of column ACCOMODATION_REQ
	 */
	protected static final int COLUMN_ACCOMODATION_REQ = 21;

	/**
	 * Index of column TYPE_OF_ACCOMODATION
	 */
	protected static final int COLUMN_TYPE_OF_ACCOMODATION = 22;

	/**
	 * Index of column CAB_REQ
	 */
	protected static final int COLUMN_CAB_REQ = 23;

	/**
	 * Index of column ONWARD_INWARD
	 */
	protected static final int COLUMN_ONWARD_INWARD = 24;

	/**
	 * Index of column CREATE_DATE
	 */
	protected static final int COLUMN_CREATE_DATE = 25;

	/**
	 * Index of column DOCUMENTS_ID
	 */
	protected static final int COLUMN_DOCUMENTS_ID = 26;

	/**
	 * here onwards columns are used for populating receive travel data
	 */
	protected static final int COLUMN_TRAVELER_EMP_ID = 27;

	protected static final int COLUMN_TRAVELER_NAME = 28;

	protected static final int COLUMN_DESIGNATION = 29;

	protected static final int COLUMN_DIVISION_ID = 30;

	protected static final int COLUMN_DIV_NAME = 31;

	protected static final int COLUMN_DEPT_ID = 32;

	protected static final int COLUMN_DEPT_NAME = 33;

	protected static final int COLUMN_REG_ID = 34;

	protected static final int COLUMN_REG_NAME = 35;

	protected static final int COLUMN_COMPANY_ID = 36;

	protected static final int COLUMN_COMPANY_NAME = 37;

	/**
	 * Index of column ESRQM_REQ_ID
	 */
	protected static final int COLUMN_ESRQM_REQ_ID = 38;

	/**
	 * Index of column STATUS_NAME
	 */
	protected static final int COLUMN_STATUS_NAME = 39;

	/**
	 * Number of columns
	 */
	protected static final int NUMBER_OF_COLUMNS = 39;

	/**
	 * Index of primary-key column ID
	 */
	protected static final int PK_COLUMN_ID = 1;

	/**
	 * Inserts a new row in the TRAVEL table.
	 */
	public TravelPk insert(Travel dto) throws TravelDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			stmt = conn.prepareStatement(SQL_INSERT,
					Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			if (dto.isEsrqmIdNull() || dto.getEsrqmId() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getEsrqmId());
			}

			stmt.setInt(index++, dto.getStatus());
			if (dto.isRaisedByNull() || dto.getRaisedBy() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getRaisedBy());
			}

			if (dto.isIsContactPersonReqNull()
					|| dto.getIsContactPersonReq() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsContactPersonReq());
			}

			stmt.setString(index++, dto.getTlType());
			stmt.setInt(index++, dto.getTrlUserId());
			stmt.setString(index++, dto.getPurposeOfTl());
			stmt.setString(index++, dto.getTravellerComments());
			stmt.setString(index++, dto.getTravellerSpouseName());
			
			if (dto.isIsRollOnNull() || dto.getIsRollOn() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsRollOn());
			}

			if (dto.isChargeCodeNull() || dto.getChargeCode() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getChargeCode());
			}

			stmt.setString(index++, dto.getModeOfTl());
			stmt.setString(index++, dto.getTlFrom());
			stmt.setString(index++, dto.getTlTo());
			stmt.setDate(index++, dto.getPrfDateToTl() == null ? null
					: new java.sql.Date(dto.getPrfDateToTl().getTime()));
			stmt.setTime(index++, dto.getPrfTimeToTl() == null ? null
					: new java.sql.Time(dto.getPrfTimeToTl().getTime()));

			if (dto.isIsRoundTripNull() || dto.getIsRoundTrip() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsRoundTrip());
			}

			stmt.setDate(index++, dto.getReturnDate() == null ? null
					: new java.sql.Date(dto.getReturnDate().getTime()));
			stmt.setTime(index++, dto.getReturnTime() == null ? null
					: new java.sql.Time(dto.getReturnTime().getTime()));

			if (dto.isAccomodationReqNull() || dto.getAccomodationReq() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getAccomodationReq());
			}

			stmt.setString(index++, dto.getTypeOfAccomodation());

			if (dto.isCabReqNull() || dto.getCabReq() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getCabReq());
			}

			if (dto.isOnwardInwardNull() || dto.getOnwardInward() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getOnwardInward());
			}

			stmt.setTimestamp(index++, dto.getCreateDate() == null ? null
					: new java.sql.Timestamp(dto.getCreateDate().getTime()));
			if (dto.isDocumentsIdNull() || dto.getDocumentsId() == 0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getDocumentsId());
			}

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}

			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}

			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()) {
				dto.setId(rs.getInt(1));
			}

			reset(dto);
			return dto.createPk();
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Updates a single row in the TRAVEL table.
	 */
	public void update(TravelPk pk, Travel dto) throws TravelDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}

			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			if (dto.isEsrqmIdNull()|| dto.getEsrqmId()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getEsrqmId());
			}

			stmt.setInt(index++, dto.getStatus());
			if (dto.isRaisedByNull()||dto.getRaisedBy()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getRaisedBy());
			}

			if (dto.isIsContactPersonReqNull()||dto.getIsContactPersonReq()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsContactPersonReq());
			}

			stmt.setString(index++, dto.getTlType());
			stmt.setInt(index++, dto.getTrlUserId());
			stmt.setString(index++, dto.getPurposeOfTl());
			stmt.setString(index++, dto.getTravellerComments());
			stmt.setString(index++, dto.getTravellerSpouseName());
			if (dto.isIsRollOnNull()||dto.getIsRollOn()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsRollOn());
			}

			if (dto.isChargeCodeNull()||dto.getChargeCode()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getChargeCode());
			}

			stmt.setString(index++, dto.getModeOfTl());
			stmt.setString(index++, dto.getTlFrom());
			stmt.setString(index++, dto.getTlTo());
			stmt.setDate(index++, dto.getPrfDateToTl() == null ? null
			: new java.sql.Date(dto.getPrfDateToTl().getTime()));
			stmt.setTime(index++, dto.getPrfTimeToTl() == null ? null
					: new java.sql.Time(dto.getPrfTimeToTl().getTime()));
			if (dto.isIsRoundTripNull()||dto.getIsRoundTrip()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getIsRoundTrip());
			}

			stmt.setDate(index++, dto.getReturnDate() == null ? null
					: new java.sql.Date(dto.getReturnDate().getTime()));
			stmt.setTime(index++, dto.getReturnTime() == null ? null
					: new java.sql.Time(dto.getReturnTime().getTime()));
			if (dto.isAccomodationReqNull()||dto.getAccomodationReq()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getAccomodationReq());
			}

			stmt.setString(index++, dto.getTypeOfAccomodation());
			if (dto.isCabReqNull()||dto.getCabReq()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getCabReq());
			}

			if (dto.isOnwardInwardNull()||dto.getOnwardInward()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getOnwardInward());
			}

			stmt.setTimestamp(index++, dto.getCreateDate() == null ? null
					: new java.sql.Timestamp(dto.getCreateDate().getTime()));
			if (dto.isDocumentsIdNull()||dto.getDocumentsId()==0) {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else {
				stmt.setInt(index++, dto.getDocumentsId());
			}

			stmt.setInt(27, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}

		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Deletes a single row in the TRAVEL table.
	 */
	public void delete(TravelPk pk) throws TravelDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}

			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}

		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Returns the rows from the TRAVEL table that matches the specified
	 * primary-key value.
	 */
	public Travel findByPrimaryKey(TravelPk pk) throws TravelDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'ID =
	 * :id'.
	 */
	public Travel findByPrimaryKey(int id) throws TravelDaoException {
		Travel ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?",
				new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria ''.
	 */
	public Travel[] findAll() throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT + " ORDER BY ID", null);
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'ID =
	 * :id'.
	 */
	public Travel[] findWhereIdEquals(int id) throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ID = ? ORDER BY ID",
				new Object[] { new Integer(id) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'ESRQM_ID
	 * = :esrqmId'.
	 */
	public Travel[] findWhereEsrqmIdEquals(int esrqmId)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE ESRQM_ID = ? ORDER BY ESRQM_ID",
				new Object[] { new Integer(esrqmId) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'STATUS =
	 * :status'.
	 */
	public Travel[] findWhereStatusEquals(int status) throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE STATUS = ? ORDER BY STATUS",
				new Object[] { new Integer(status) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'RAISED_BY
	 * = :raisedBy'.
	 */
	public Travel[] findWhereRaisedByEquals(int raisedBy)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE RAISED_BY = ? ORDER BY RAISED_BY",
				new Object[] { new Integer(raisedBy) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'IS_CONTACT_PERSON_REQ = :isContactPersonReq'.
	 */
	public Travel[] findWhereIsContactPersonReqEquals(int isContactPersonReq)
			throws TravelDaoException {
		return findByDynamicSelect(
				SQL_SELECT
						+ " WHERE IS_CONTACT_PERSON_REQ = ? ORDER BY IS_CONTACT_PERSON_REQ",
				new Object[] { new Integer(isContactPersonReq) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'TL_TYPE =
	 * :tlType'.
	 */
	public Travel[] findWhereTlTypeEquals(String tlType)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE TL_TYPE = ? ORDER BY TL_TYPE",
				new Object[] { tlType });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'TRL_USER_ID = :trlUserId'.
	 */
	public Travel[] findWhereTrlUserIdEquals(int trlUserId)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE TRL_USER_ID = ? ORDER BY TRL_USER_ID",
				new Object[] { new Integer(trlUserId) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'PURPOSE_OF_TL = :purposeOfTl'.
	 */
	public Travel[] findWherePurposeOfTlEquals(String purposeOfTl)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE PURPOSE_OF_TL = ? ORDER BY PURPOSE_OF_TL",
				new Object[] { purposeOfTl });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'TRAVELLER_COMMENTS = :travellerComments'.
	 */
	public Travel[] findWhereTravellerCommentsEquals(String travellerComments)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE TRAVELLER_COMMENTS = ? ORDER BY TRAVELLER_COMMENTS",
				new Object[] { travellerComments });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'SPOUSE_NAME = :spouseName'.
	 */
	public Travel[] findWhereSpouseNameEquals(String spouseName)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE SPOUSE_NAME = ? ORDER BY SPOUSE_NAME",
				new Object[] { spouseName });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'IS_ROLL_ON = :isRollOn'.
	 */
	public Travel[] findWhereIsRollOnEquals(int isRollOn)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE IS_ROLL_ON = ? ORDER BY IS_ROLL_ON",
				new Object[] { new Integer(isRollOn) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'CHARGE_CODE = :chargeCode'.
	 */
	public Travel[] findWhereChargeCodeEquals(int chargeCode)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE CHARGE_CODE = ? ORDER BY CHARGE_CODE",
				new Object[] { new Integer(chargeCode) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'MODE_OF_TL = :modeOfTl'.
	 */
	public Travel[] findWhereModeOfTlEquals(String modeOfTl)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE MODE_OF_TL = ? ORDER BY MODE_OF_TL",
				new Object[] { modeOfTl });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'TL_FROM =
	 * :tlFrom'.
	 */
	public Travel[] findWhereTlFromEquals(String tlFrom)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE TL_FROM = ? ORDER BY TL_FROM",
				new Object[] { tlFrom });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'TL_TO =
	 * :tlTo'.
	 */
	public Travel[] findWhereTlToEquals(String tlTo) throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE TL_TO = ? ORDER BY TL_TO", new Object[] { tlTo });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'PRF_DATE_TO_TL = :prfDateToTl'.
	 */
	public Travel[] findWherePrfDateToTlEquals(Date prfDateToTl)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE PRF_DATE_TO_TL = ? ORDER BY PRF_DATE_TO_TL",
				new Object[] { prfDateToTl == null ? null : new java.sql.Date(
						prfDateToTl.getTime()) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'PRF_TIME_TO_TL = :prfTimeToTl'.
	 */
	public Travel[] findWherePrfTimeToTlEquals(Date prfTimeToTl)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE PRF_TIME_TO_TL = ? ORDER BY PRF_TIME_TO_TL",
				new Object[] { prfTimeToTl == null ? null : new java.sql.Time(
						prfTimeToTl.getTime()) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'IS_ROUND_TRIP = :isRoundTrip'.
	 */
	public Travel[] findWhereIsRoundTripEquals(int isRoundTrip)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE IS_ROUND_TRIP = ? ORDER BY IS_ROUND_TRIP",
				new Object[] { new Integer(isRoundTrip) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'RETURN_DATE = :returnDate'.
	 */
	public Travel[] findWhereReturnDateEquals(Date returnDate)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE RETURN_DATE = ? ORDER BY RETURN_DATE",
				new Object[] { returnDate == null ? null : new java.sql.Date(
						returnDate.getTime()) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'RETURN_TIME = :returnTime'.
	 */
	public Travel[] findWhereReturnTimeEquals(Date returnTime)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE RETURN_TIME = ? ORDER BY RETURN_TIME",
				new Object[] { returnTime == null ? null : new java.sql.Time(
						returnTime.getTime()) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'ACCOMODATION_REQ = :accomodationReq'.
	 */
	public Travel[] findWhereAccomodationReqEquals(int accomodationReq)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE ACCOMODATION_REQ = ? ORDER BY ACCOMODATION_REQ",
				new Object[] { new Integer(accomodationReq) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'TYPE_OF_ACCOMODATION = :typeOfAccomodation'.
	 */
	public Travel[] findWhereTypeOfAccomodationEquals(String typeOfAccomodation)
			throws TravelDaoException {
		return findByDynamicSelect(
				SQL_SELECT
						+ " WHERE TYPE_OF_ACCOMODATION = ? ORDER BY TYPE_OF_ACCOMODATION",
				new Object[] { typeOfAccomodation });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria 'CAB_REQ =
	 * :cabReq'.
	 */
	public Travel[] findWhereCabReqEquals(int cabReq) throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE CAB_REQ = ? ORDER BY CAB_REQ",
				new Object[] { new Integer(cabReq) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'ONWARD_INWARD = :onwardInward'.
	 */
	public Travel[] findWhereOnwardInwardEquals(int onwardInward)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE ONWARD_INWARD = ? ORDER BY ONWARD_INWARD",
				new Object[] { new Integer(onwardInward) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'CREATE_DATE = :createDate'.
	 */
	public Travel[] findWhereCreateDateEquals(Date createDate)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE CREATE_DATE = ? ORDER BY CREATE_DATE",
				new Object[] { createDate == null ? null
						: new java.sql.Timestamp(createDate.getTime()) });
	}

	/**
	 * Returns all rows from the TRAVEL table that match the criteria
	 * 'DOCUMENTS_ID = :documentsId'.
	 */
	public Travel[] findWhereDocumentsIdEquals(int documentsId)
			throws TravelDaoException {
		return findByDynamicSelect(SQL_SELECT
				+ " WHERE DOCUMENTS_ID = ? ORDER BY DOCUMENTS_ID",
				new Object[] { new Integer(documentsId) });
	}

	/**
	 * Method 'TravelDaoImpl'
	 * 
	 */
	public TravelDaoImpl() {
	}

	/**
	 * Method 'TravelDaoImpl'
	 * 
	 * @param userConn
	 */
	public TravelDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName() {
		return "TRAVEL";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected Travel fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()) {
			Travel dto = new Travel();
			populateDto(dto, rs);
			return dto;
		} else {
			return null;
		}

	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected Travel[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<Travel> resultList = new ArrayList<Travel>();
		while (rs.next()) {
			Travel dto = new Travel();
			populateDto(dto, rs);
			resultList.add(dto);
		}

		Travel ret[] = new Travel[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(Travel dto, ResultSet rs) throws SQLException {
		dto.setId(rs.getInt(COLUMN_ID));
		dto.setEsrqmId(rs.getInt(COLUMN_ESRQM_ID));
		if (rs.wasNull()) {
			dto.setEsrqmIdNull(true);
		}

		dto.setStatus(rs.getInt(COLUMN_STATUS));
		dto.setRaisedBy(rs.getInt(COLUMN_RAISED_BY));
		if (rs.wasNull()) {
			dto.setRaisedByNull(true);
		}

		dto.setIsContactPersonReq(rs.getInt(COLUMN_IS_CONTACT_PERSON_REQ));
		if (rs.wasNull()) {
			dto.setIsContactPersonReqNull(true);
		}

		dto.setTlType(rs.getString(COLUMN_TL_TYPE));
		dto.setTrlUserId(rs.getInt(COLUMN_TRL_USER_ID));
		dto.setPurposeOfTl(rs.getString(COLUMN_PURPOSE_OF_TL));
		dto.setTravellerComments(rs.getString(COLUMN_TRAVELLER_COMMENTS));
		dto.setTravellerSpouseName(rs.getString(COLUMN_SPOUSE_NAME));
		dto.setIsRollOn(rs.getInt(COLUMN_IS_ROLL_ON));
		if (rs.wasNull()) {
			dto.setIsRollOnNull(true);
		}

		dto.setChargeCode(rs.getInt(COLUMN_CHARGE_CODE));
		if (rs.wasNull()) {
			dto.setChargeCodeNull(true);
		}

		dto.setModeOfTl(rs.getString(COLUMN_MODE_OF_TL));
		dto.setTlFrom(rs.getString(COLUMN_TL_FROM));
		dto.setTlTo(rs.getString(COLUMN_TL_TO));
		dto.setPrfDateToTl(rs.getDate(COLUMN_PRF_DATE_TO_TL));
		dto.setPrfTimeToTl(rs.getTime(COLUMN_PRF_TIME_TO_TL));
		dto.setIsRoundTrip(rs.getInt(COLUMN_IS_ROUND_TRIP));
		if (rs.wasNull()) {
			dto.setIsRoundTripNull(true);
		}

		dto.setReturnDate(rs.getDate(COLUMN_RETURN_DATE));
		dto.setReturnTime(rs.getTime(COLUMN_RETURN_TIME));
		dto.setAccomodationReq(rs.getInt(COLUMN_ACCOMODATION_REQ));
		if (rs.wasNull()) {
			dto.setAccomodationReqNull(true);
		}

		dto.setTypeOfAccomodation(rs.getString(COLUMN_TYPE_OF_ACCOMODATION));
		dto.setCabReq(rs.getInt(COLUMN_CAB_REQ));
		if (rs.wasNull()) {
			dto.setCabReqNull(true);
		}

		dto.setOnwardInward(rs.getInt(COLUMN_ONWARD_INWARD));
		if (rs.wasNull()) {
			dto.setOnwardInwardNull(true);
		}

		dto.setCreateDate(rs.getTimestamp(COLUMN_CREATE_DATE));
		dto.setDocumentsId(rs.getInt(COLUMN_DOCUMENTS_ID));
		if (rs.wasNull()) {
			dto.setDocumentsIdNull(true);
		}

	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(Travel dto) {
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected TravelRequest fetchTravelResults(ResultSet rs)
			throws SQLException {
		Collection<TravelRequest> resultList = new ArrayList<TravelRequest>();
		while (rs.next()) {
			TravelRequest dto = new TravelRequest();
			populateDto(dto, rs);
			resultList.add(dto);
		}

		TravelRequest ret[] = new TravelRequest[resultList.size()];
		resultList.toArray(ret);
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(TravelRequest dto, ResultSet rs)
			throws SQLException {

		dto.setTravelId(rs.getInt(COLUMN_ID));
		dto.setEsrqmId(rs.getInt(COLUMN_ESRQM_ID));
		dto.setStatus(rs.getInt(COLUMN_STATUS));
		dto.setIscontactPersonReq(rs.getInt(COLUMN_IS_CONTACT_PERSON_REQ));
		dto.setTlType(rs.getString(COLUMN_TL_TYPE));
		dto.setTrlUserId(rs.getInt(COLUMN_TRL_USER_ID));
		dto.setPurposeOfTl(rs.getString(COLUMN_PURPOSE_OF_TL));
		dto.setIsRollOn(rs.getInt(COLUMN_IS_ROLL_ON));
		dto.setChargeCode(rs.getInt(COLUMN_CHARGE_CODE));
		dto.setModeOfTl(rs.getString(COLUMN_MODE_OF_TL));
		dto.setTlFrom(rs.getString(COLUMN_TL_FROM));
		dto.setTlTo(rs.getString(COLUMN_TL_TO));
		dto.setPrfDateToTl(PortalUtility.formatDateddMMyyyy(rs
				.getDate(COLUMN_PRF_DATE_TO_TL)));
		dto.setPrfTimeToTl(PortalUtility.formatTime(rs
				.getTime(COLUMN_PRF_TIME_TO_TL)));
		dto.setIsRoundTrip(rs.getInt(COLUMN_IS_ROUND_TRIP));
		dto.setReturnDate(PortalUtility.formatDateddMMyyyy(rs
				.getDate(COLUMN_RETURN_DATE)));
		dto.setReturnTime(PortalUtility.formatTime(rs
				.getTime(COLUMN_RETURN_TIME)));
		dto.setAccomodationReq(rs.getInt(COLUMN_ACCOMODATION_REQ));
		dto.setTypeOfAccomodation(rs.getString(COLUMN_TYPE_OF_ACCOMODATION));
		dto.setCabReq(rs.getInt(COLUMN_CAB_REQ));
		dto.setOnwardInward(rs.getInt(COLUMN_ONWARD_INWARD));
		dto.setEmpId(rs.getInt(COLUMN_TRAVELER_EMP_ID));
		dto.setTravelerName(rs.getString(COLUMN_TRAVELER_NAME));
		dto.setDesignation(rs.getString(COLUMN_DESIGNATION));
		dto.setDivisionId(rs.getInt(COLUMN_DIVISION_ID));
		dto.setDivisionName(rs.getString(COLUMN_DIV_NAME));
		dto.setDepartmentId(rs.getInt(COLUMN_DEPT_ID));
		dto.setDepartmentName(rs.getString(COLUMN_DEPT_NAME));
		dto.setRegionId(rs.getInt(COLUMN_REG_ID));
		dto.setRegName(rs.getString(COLUMN_REG_NAME));
		dto.setCompanyId(rs.getInt(COLUMN_COMPANY_ID));
		dto.setCompanyName(rs.getString(COLUMN_COMPANY_NAME));
		dto.setCreatedDate(PortalUtility.formatDateToddmmyyyyhhmmss(rs
				.getTimestamp(COLUMN_CREATE_DATE)));
		dto.setEmpServReqMapId(rs.getString(COLUMN_ESRQM_REQ_ID));
		dto.setStatusName(rs.getString(COLUMN_STATUS_NAME));
		dto.setRaisedBy(rs.getInt(COLUMN_RAISED_BY));
		dto.setDocumentsId(rs.getInt(COLUMN_DOCUMENTS_ID));
		dto.setTravellerComments(rs.getString(COLUMN_TRAVELLER_COMMENTS));
		dto.setTravellerSpouseName(rs.getString(COLUMN_SPOUSE_NAME));
	}

	/**
	 * Returns all rows from the TRAVEL table that match the specified arbitrary
	 * SQL statement
	 */
	public Travel[] findByDynamicSelect(String sql, Object[] sqlParams)
			throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = sql;

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++) {
				stmt.setObject(i + 1, sqlParams[i]);
			}

			rs = stmt.executeQuery();

			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Returns all rows from the TRAVEL table that match the specified arbitrary
	 * SQL statement
	 */
	public Travel[] findByDynamicWhere(String sql, Object[] sqlParams)
			throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++) {
				stmt.setObject(i + 1, sqlParams[i]);
			}

			rs = stmt.executeQuery();

			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Returns all rows from the TRAVEL table that match the specified arbitrary
	 * SQL statement
	 */
	@Override
	public TravelRequest findTravelId(Object[] sqlParams)
			throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = "SELECT TL.ID AS TRAVEL_ID, TL.ESRQM_ID, TL.STATUS AS MAIN_STATUS,TL.RAISED_BY ,TL.IS_CONTACT_PERSON_REQ, TL.TL_TYPE, TL.TRL_USER_ID, TL.PURPOSE_OF_TL, TL.TRAVELLER_COMMENTS, TL.SPOUSE_NAME, TL.IS_ROLL_ON, TL.CHARGE_CODE, TL.MODE_OF_TL, TL.TL_FROM, TL.TL_TO, TL.PRF_DATE_TO_TL, TL.PRF_TIME_TO_TL, TL.IS_ROUND_TRIP, TL.RETURN_DATE, TL.RETURN_TIME, TL.ACCOMODATION_REQ, TL.TYPE_OF_ACCOMODATION, TL.CAB_REQ, TL.ONWARD_INWARD,TL.CREATE_DATE,TL.DOCUMENTS_ID,U.EMP_ID, CONCAT(PF.FIRST_NAME, \" \",PF.LAST_NAME) AS TL_NAME, L.DESIGNATION, D.ID AS DIVISION_ID , D.NAME AS DIV_NAME, DV.ID AS DEPT_ID, DV.NAME AS DEPT_NAME, R.ID AS REG_ID, R.REG_NAME, C.ID AS COMP_ID, C.COMPANY_NAME,EMP.REQ_ID AS ESRQM_REQ_ID,ST.STATUS AS STATUS_NAME FROM TRAVEL TL LEFT JOIN USERS U ON TL.TRL_USER_ID = U.ID LEFT JOIN EMP_SER_REQ_MAP EMP ON TL.ESRQM_ID=EMP.ID LEFT JOIN STATUS ST ON ST.ID=TL.STATUS LEFT JOIN PROFILE_INFO PF ON PF.ID = U.PROFILE_ID LEFT JOIN LEVELS L ON PF.LEVEL_ID = L.ID LEFT JOIN DIVISON D ON L.DIVISION_ID = D.ID LEFT JOIN DIVISON DV ON DV.ID = D.PARENT_ID LEFT JOIN REGIONS R ON D.REGION_ID = R.ID LEFT JOIN COMPANY C ON C.ID = R.COMPANY_ID WHERE TL.ID IN(?)";

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++) {
				stmt.setObject(i + 1, sqlParams[i]);
			}

			rs = stmt.executeQuery();

			// fetch the results
			return fetchTravelResults(rs);
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	@Override
	public TravelForm[] findTravellerDetailsByEmpId(Object[] sqlParams)
			throws TravelDaoException

	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = "SELECT U.ID,U.EMP_ID,PRO.FIRST_NAME,PRO.LAST_NAME,L.DESIGNATION,D.ID,D.NAME,R.REG_NAME,C.ID,C.COMPANY_NAME FROM USERS U LEFT JOIN PROFILE_INFO PRO ON U.PROFILE_ID=PRO.ID LEFT JOIN LEVELS L ON U.LEVEL_ID=L.ID LEFT JOIN DIVISON D ON L.DIVISION_ID=D.ID LEFT JOIN  REGIONS R ON R.ID=D.REGION_ID LEFT JOIN COMPANY C ON C.ID=R.COMPANY_ID WHERE U.EMP_ID=? AND U.STATUS=0";

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++) {
				stmt.setObject(i + 1, sqlParams[i]);
			}

			rs = stmt.executeQuery();

			// fetch the results
			return fetchTravellerDetails(rs);
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected TravelForm[] fetchTravellerDetails(ResultSet rs)
			throws SQLException {
		Collection<TravelForm> resultList = new ArrayList<TravelForm>();
		while (rs.next()) {
			TravelForm dto = new TravelForm();
			populateTravellerDto(dto, rs);
			resultList.add(dto);
		}

		TravelForm ret[] = new TravelForm[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	protected void populateTravellerDto(TravelForm dto, ResultSet rs)
			throws SQLException {

		dto.setTrlUserId(rs.getInt(INDEX));
		dto.setEmpId(rs.getInt(++INDEX));
		dto.setTravelerName(rs.getString(++INDEX) + " "	+ rs.getString(++INDEX));
		dto.setDesignation(rs.getString(++INDEX));
		dto.setDivisionId(rs.getInt(++INDEX));
		dto.setDivisionName(rs.getString(++INDEX));
		dto.setRegName(rs.getString(++INDEX));
		dto.setCompanyId(rs.getInt(++INDEX));
		dto.setCompanyName(rs.getString(++INDEX));
	}

	public void executeUpdate(String sql) throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = sql;

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			stmt.executeUpdate();
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	public String getCommentsHistory(int esrMapId) throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			// construct the SQL statement
			final String SQL = "SELECT COMMENTS_HISTORY FROM TRAVEL WHERE ESRQM_ID="
					+ esrMapId;

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			rs = stmt.executeQuery();
			if (rs != null && rs.next()) {
				return rs.getString("COMMENTS_HISTORY");
			}
			return null;
		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	public void appendCommentsHistory(int esrMapId, String newComment)
			throws TravelDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();

			String SQL = null;

			String oldComment = getCommentsHistory(esrMapId);
			if (oldComment == null) {
				SQL = "UPDATE TRAVEL SET COMMENTS_HISTORY='" + newComment
						+ "' WHERE ESRQM_ID=" + esrMapId;
			} else {
				SQL = "UPDATE TRAVEL SET COMMENTS_HISTORY='" + oldComment
						+ newComment + "' WHERE ESRQM_ID=" + esrMapId;
			}

			if (logger.isDebugEnabled()) {
				logger.debug("Executing " + SQL);
			}

			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);

			executeUpdate(SQL);

		} catch (Exception _e) {
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new TravelDaoException("Exception: " + _e.getMessage(), _e);
		} finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}

		}

	}

	@Override
	public Travel[] findWhereCommentsHistoryEquals(String commentsHistory)
			throws TravelDaoException {
		// TODO Auto-generated method stub
		return null;
	}

}
