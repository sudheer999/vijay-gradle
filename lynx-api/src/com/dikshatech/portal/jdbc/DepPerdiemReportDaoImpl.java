/*
 * This source file was generated by FireStorm/DAO.
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * For more information please visit http://www.codefutures.com/products/firestorm
 */
package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import com.dikshatech.beans.PerdiemReportBean;
import com.dikshatech.common.utils.DesEncrypterDecrypter;
import com.dikshatech.common.utils.PortalUtility;
import com.dikshatech.portal.dao.DepPerdiemReportDao;
import com.dikshatech.portal.dto.DepPerdiemReport;
import com.dikshatech.portal.dto.DepPerdiemReportPk;
import com.dikshatech.portal.exceptions.DepPerdiemReportDaoException;
import com.dikshatech.portal.exceptions.DepPerdiemReqDaoException;
import com.dikshatech.portal.factory.CurrencyDaoFactory;
import com.dikshatech.portal.models.ReconciliationModel;

public class DepPerdiemReportDaoImpl extends AbstractDAO implements DepPerdiemReportDao {

	/**
	 * The factory class for this DAO has two versions of the create() method - one that
	 * takes no arguments and one that takes a Connection argument. If the Connection version
	 * is chosen then the connection will be stored in this attribute and will be used by all
	 * calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection	userConn;
	protected static final Logger	logger		= Logger.getLogger(DepPerdiemReportDaoImpl.class);
	/**
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String			SQL_SELECT	= "SELECT ID, DEP_ID, USER_ID, PAYABLE_DAYS, PERDIEM, CURRENCY_TYPE, AMOUNT, AMOUNT_INR, TOTAL, MANAGER_ID, MANAGER_NAME, CLIENT_NAME, MODIFIED_BY, MODIFIED_ON, TYPE, COMMENTS,PERDIEM_FROM, PERDIEM_TO, ACCOUNT_TYPE,SALARY_CYCLE,PAID,LWP_DAYS, SALARY_ADVANCE_DEDUCTION, TRAVEL_ADVANCE_DEDUCTION,NO_OF_MODIFICATIONS,REASON_FOR_NONPAYMENT,DATE FROM " + getTableName() + "";
	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int					maxRows;
	/**
	 * SQL INSERT statement for this table
	 */
	protected final String			SQL_INSERT	= "INSERT INTO " + getTableName() + " ( ID, DEP_ID, USER_ID, PAYABLE_DAYS, PERDIEM, CURRENCY_TYPE, AMOUNT, AMOUNT_INR, TOTAL, MANAGER_ID, MANAGER_NAME, CLIENT_NAME, MODIFIED_BY, MODIFIED_ON, TYPE, COMMENTS, PERDIEM_FROM, PERDIEM_TO, ACCOUNT_TYPE,SALARY_CYCLE,LWP_DAYS, SALARY_ADVANCE_DEDUCTION, TRAVEL_ADVANCE_DEDUCTION) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?)";
	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String			SQL_UPDATE	= "UPDATE " + getTableName() + " SET ID = ?, DEP_ID = ?, USER_ID = ?, PAYABLE_DAYS = ?, PERDIEM = ?, CURRENCY_TYPE = ?, AMOUNT = ?, AMOUNT_INR = ?, TOTAL = ?,  MANAGER_ID = ?, MANAGER_NAME = ?, CLIENT_NAME = ?, MODIFIED_BY = ?, MODIFIED_ON = ?, TYPE = ?, COMMENTS = ?,PERDIEM_FROM = ?, PERDIEM_TO = ?, ACCOUNT_TYPE = ?, SALARY_CYCLE=?, LWP_DAYS=?, SALARY_ADVANCE_DEDUCTION=?, TRAVEL_ADVANCE_DEDUCTION=?, NO_OF_MODIFICATIONS=? WHERE ID = ?";
	/**
	 * SQL DELETE statement for this table
	 */
	protected final String			SQL_DELETE	= "DELETE FROM " + getTableName() + " WHERE ID = ?";

	/**
	 * Inserts a new row in the dep_perdiem_report table.
	 */
	public DepPerdiemReportPk insert(DepPerdiemReport dto) throws DepPerdiemReportDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			stmt = conn.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setInt(index++, dto.getDepId());
			stmt.setInt(index++, dto.getUserId());
			stmt.setFloat(index++, dto.getPayableDays());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getPerdiem()));
			stmt.setInt(index++, dto.getCurrencyType());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getAmount()));
			stmt.setString(index++, dto.getAmountInr() == null ? null : DesEncrypterDecrypter.getInstance().encrypt(dto.getAmountInr()));
			stmt.setString(index++, dto.getTotal() == null ? null : DesEncrypterDecrypter.getInstance().encrypt(dto.getTotal()));
			stmt.setInt(index++, dto.getManagerId());
			stmt.setString(index++, dto.getManagerName());
			stmt.setString(index++, dto.getClientName());
			stmt.setString(index++, dto.getModifiedBy());
			stmt.setTimestamp(index++, dto.getModifiedOn() == null ? null : new java.sql.Timestamp(dto.getModifiedOn().getTime()));
			stmt.setShort(index++, dto.getType());
			stmt.setString(index++, dto.getComments());
			stmt.setTimestamp(index++, dto.getFrom() == null ? null : new java.sql.Timestamp(dto.getFrom().getTime()));
			stmt.setTimestamp(index++, dto.getTo() == null ? null : new java.sql.Timestamp(dto.getTo().getTime()));
			stmt.setShort(index++, dto.getAccountType());
			stmt.setString(index++, dto.getSalaryCycle());
			stmt.setFloat(index++, dto.getLwpDays());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getSalaryAdvanceDeduction()));
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getTravelAdvanceDeduction()));
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()){
				dto.setId(rs.getInt(1));
			}
			reset(dto);
			return dto.createPk();
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Updates a single row in the dep_perdiem_report table.
	 */
	public void update(DepPerdiemReportPk pk, DepPerdiemReport dto) throws DepPerdiemReportDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setInt(index++, dto.getDepId());
			stmt.setInt(index++, dto.getUserId());
			stmt.setFloat(index++, dto.getPayableDays());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getPerdiem()));
			stmt.setInt(index++, dto.getCurrencyType());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getAmount()));
			stmt.setString(index++, dto.getAmountInr() == null ? null : DesEncrypterDecrypter.getInstance().encrypt(dto.getAmountInr()));
			stmt.setString(index++, dto.getTotal() == null ? null : DesEncrypterDecrypter.getInstance().encrypt(dto.getTotal()));
			stmt.setInt(index++, dto.getManagerId());
			stmt.setString(index++, dto.getManagerName());
			stmt.setString(index++, dto.getClientName());
			stmt.setString(index++, dto.getModifiedBy());
			stmt.setTimestamp(index++, dto.getModifiedOn() == null ? null : new java.sql.Timestamp(dto.getModifiedOn().getTime()));
			stmt.setShort(index++, dto.getType());
			stmt.setString(index++, dto.getComments());
			stmt.setTimestamp(index++, dto.getFrom() == null ? null : new java.sql.Timestamp(dto.getFrom().getTime()));
			stmt.setTimestamp(index++, dto.getTo() == null ? null : new java.sql.Timestamp(dto.getTo().getTime()));
			stmt.setShort(index++, dto.getAccountType());
			stmt.setString(index++, dto.getSalaryCycle());
			stmt.setFloat(index++, dto.getLwpDays());
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getSalaryAdvanceDeduction()));
			stmt.setString(index++, DesEncrypterDecrypter.getInstance().encrypt(dto.getTravelAdvanceDeduction()));
			stmt.setString(index++, dto.getNoOfModifications());
			stmt.setInt(index++, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Deletes a single row in the dep_perdiem_report table.
	 */
	public void delete(DepPerdiemReportPk pk) throws DepPerdiemReportDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}
			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns the rows from the dep_perdiem_report table that matches the specified primary-key value.
	 */
	public DepPerdiemReport findByPrimaryKey(DepPerdiemReportPk pk) throws DepPerdiemReportDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the criteria 'ID = :id'.
	 */
	public DepPerdiemReport findByPrimaryKey(int id) throws DepPerdiemReportDaoException {
		DepPerdiemReport ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?", new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the criteria 'DEP_ID = :depId'.
	 */
	
	
	
	public DepPerdiemReport[] findWhereDepIdEquals(int depId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect("SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME),P.CATEGORY FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID WHERE DEP_ID = ? ORDER BY U.EMP_ID,CLIENT_NAME", new Object[] { new Integer(depId) });
	}

	public DepPerdiemReport[] findWhereDepIdEqualsHdfc(int depId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect2("SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID WHERE DEP_ID = ? AND F.PRIM_BANK_NAME LIKE '%HDFC%' AND (DPR.PAID is null or DPR.PAID = '') ORDER BY U.EMP_ID,CLIENT_NAME", new Object[] { new Integer(depId) });
	}

	public DepPerdiemReport[] findWhereDepIdEqualsNonHdfc(int depId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect2("SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID  WHERE DEP_ID = ? AND F.PRIM_BANK_NAME NOT LIKE '%HDFC%'  AND (DPR.PAID is null or DPR.PAID = '') ORDER BY U.EMP_ID,CLIENT_NAME", new Object[] { new Integer(depId) });
	}
	
	public DepPerdiemReport[] findWhereDepIdEquals(int depId, int managerId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect("SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID WHERE DEP_ID = ? AND MANAGER_ID = ? ORDER BY CLIENT_NAME, EMP_ID", new Object[] { new Integer(depId), new Integer(managerId) });
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the criteria 'USER_ID = :userId'.
	 */
	public DepPerdiemReport[] findWhereUserIdEquals(int userId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE USER_ID = ? ORDER BY USER_ID", new Object[] { new Integer(userId) });
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the criteria 'MANAGER_ID = :managerId'.
	 */
	public DepPerdiemReport[] findWhereManagerIdEquals(int managerId) throws DepPerdiemReportDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE MANAGER_ID = ? ORDER BY MANAGER_ID", new Object[] { new Integer(managerId) });
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the criteria 'IS_DELETED = :isDeleted'.
	 */
	public DepPerdiemReport[] findWhereIsDeletedEquals(short isDeleted) throws DepPerdiemReportDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE IS_DELETED = ? ORDER BY IS_DELETED", new Object[] { new Short(isDeleted) });
	}

	/**
	 * Method 'DepPerdiemReportDaoImpl'
	 */
	public DepPerdiemReportDaoImpl() {}

	/**
	 * Method 'DepPerdiemReportDaoImpl'
	 * 
	 * @param userConn
	 */
	public DepPerdiemReportDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName() {
		return "DEP_PERDIEM_REPORT";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected DepPerdiemReport fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()){
			DepPerdiemReport dto = new DepPerdiemReport();
			populateDto(dto, rs);
			return dto;
		} else{
			return null;
		}
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected DepPerdiemReport[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<DepPerdiemReport> resultList = new ArrayList<DepPerdiemReport>();
		while (rs.next()){
			DepPerdiemReport dto = new DepPerdiemReport();
			populateDto(dto, rs);
			resultList.add(dto);
		}
		DepPerdiemReport ret[] = new DepPerdiemReport[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}
	/**
	 * Fetches multiple rows from the result set
	 */
	protected DepPerdiemReport[] fetchMultiResults2(ResultSet rs) throws SQLException {
		Collection<DepPerdiemReport> resultList = new ArrayList<DepPerdiemReport>();
		while (rs.next()){
			DepPerdiemReport dto = new DepPerdiemReport();
			populateDto2(dto, rs);
			resultList.add(dto);
		}
		DepPerdiemReport ret[] = new DepPerdiemReport[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}
	
	protected void populateDto1(DepPerdiemReport dto, ResultSet rs) throws SQLException {
		int index = 1;
		dto.setId(rs.getInt(index++));
		dto.setDepId(rs.getInt(index++));
		dto.setUserId(rs.getInt(index++));
		dto.setPayableDays(rs.getFloat(index++));
		try{
			int columnid = index++;
			dto.setPerdiem(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setCurrencyType(rs.getInt(index++));
		try{
			int columnid = index++;
			dto.setAmount(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setAmountInr(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setTotal(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setManagerId(rs.getInt(index++));
		dto.setManagerName(rs.getString(index++));
		dto.setClientName(rs.getString(index++));
		dto.setModifiedBy(rs.getString(index++));
		//dto.setModifiedOn(rs.getTimestamp(index++));
		
		dto.setModifiedOn(rs.getDate(index++));
		                                    
		dto.setType(rs.getShort(index++));
		dto.setComments(rs.getString(index++));
		dto.setFrom(rs.getDate(index++));
		dto.setTo(rs.getDate(index++));
		dto.setAccountType(rs.getShort(index++));
		dto.setSalaryCycle(rs.getString(index++));
		dto.setPaid(rs.getString(index++));
		
		try{
			dto.setEmpId(rs.getObject(index++).toString());
			dto.setEmployeeName(rs.getString(index++));
			
		} catch (Exception e){}
		
		
		
	}
	/**
	 * Populates a DTO with data from a ResultSet HDFC OR NON HDFC
	 */
	protected void populateDto2(DepPerdiemReport dto, ResultSet rs) throws SQLException {
		int index = 1;
		dto.setId(rs.getInt(index++));
		dto.setDepId(rs.getInt(index++));
		dto.setUserId(rs.getInt(index++));
		dto.setPayableDays(rs.getFloat(index++));
		try{
			int columnid = index++;
			dto.setPerdiem(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setCurrencyType(rs.getInt(index++));
		try{
			int columnid = index++;
			dto.setAmount(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setAmountInr(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setTotal(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setManagerId(rs.getInt(index++));
		dto.setManagerName(rs.getString(index++));
		dto.setClientName(rs.getString(index++));
		dto.setModifiedBy(rs.getString(index++));
		//dto.setModifiedOn(rs.getTimestamp(index++));
		dto.setModifiedOn(rs.getDate(index++));
		dto.setType(rs.getShort(index++));
		dto.setComments(rs.getString(index++));
		dto.setFrom(rs.getDate(index++));
		dto.setTo(rs.getDate(index++));
		dto.setAccountType(rs.getShort(index++));
		dto.setSalaryCycle(rs.getString(index++));
		dto.setPaid(rs.getString(index++));
		
		try{
			dto.setEmpId(rs.getObject(index++).toString());
			dto.setEmployeeName(rs.getString(index++));
			
		} catch (Exception e){}
		
		
	}

	
	


	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(DepPerdiemReport dto, ResultSet rs) throws SQLException {
		int index = 1;
		dto.setId(rs.getInt(index++));
		dto.setDepId(rs.getInt(index++));
		dto.setUserId(rs.getInt(index++));
		dto.setPayableDays(rs.getFloat(index++));
		try{
			int columnid = index++;
			dto.setPerdiem(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setCurrencyType(rs.getInt(index++));
		try{
			int columnid = index++;
			dto.setAmount(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setAmountInr(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
			dto.setTotal(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		dto.setManagerId(rs.getInt(index++));
		dto.setManagerName(rs.getString(index++));
		dto.setClientName(rs.getString(index++));
		dto.setModifiedBy(rs.getString(index++));
		//dto.setModifiedOn(rs.getTimestamp(index++));
		dto.setModifiedOn(rs.getDate(index++));
		dto.setType(rs.getShort(index++));
		dto.setComments(rs.getString(index++));
		dto.setFrom(rs.getDate(index++));
		dto.setTo(rs.getDate(index++));
		dto.setAccountType(rs.getShort(index++));
		dto.setSalaryCycle(rs.getString(index++));
		dto.setPaid(rs.getString(index++));
		dto.setLwpDays(rs.getFloat(index++));
		try{
			int columnid = index++;
		dto.setSalaryAdvanceDeduction(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		} catch (Exception e1){}
		try{
			int columnid = index++;
		dto.setTravelAdvanceDeduction(new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(columnid)))));
		}catch (Exception e1){}
		dto.setNoOfModifications(rs.getString(index++));
        dto.setReason(rs.getString(index++));
		dto.setDate(rs.getString(index++));
		try{
			dto.setEmpId(rs.getString(index++));
			dto.setEmployeeName(rs.getString(index++));
			dto.setCategory(rs.getString(index++));
		
		} catch (Exception e){}
		
		
	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(DepPerdiemReport dto) {}
	
	/**
	 * Returns all rows from the dep_perdiem_report table that match the specified arbitrary SQL statement FOR HDFC OR NON_HDFC
	 */
	public DepPerdiemReport[] findByDynamicSelect2(String sql, Object[] sqlParams) throws DepPerdiemReportDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults2(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
	
	

	/**
	 * Returns all rows from the dep_perdiem_report table that match the specified arbitrary SQL statement
	 */
	public DepPerdiemReport[] findByDynamicSelect(String sql, Object[] sqlParams) throws DepPerdiemReportDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the dep_perdiem_report table that match the specified arbitrary SQL statement
	 */
	public DepPerdiemReport[] findByDynamicWhere(String sql, Object[] sqlParams) throws DepPerdiemReportDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
	
	
	@Override
	public DepPerdiemReport[] findAllPaidAndUnpaid(int id, String flagBank) throws DepPerdiemReportDaoException {
		
		   final boolean isConnSupplied = (userConn != null);
	        Connection conn = null;
	        PreparedStatement stmt = null;
	        ResultSet rs = null;
		
	 try{
		  conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		  
	 String SQL_HDFC="SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID  WHERE  F.PRIM_BANK_NAME LIKE '%HDFC%' AND  DEP_ID = ? ORDER BY U.EMP_ID,CLIENT_NAME";
	
	 String SQL_NON_HDFC="SELECT DPR.*,U.EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME FROM DEP_PERDIEM_REPORT DPR JOIN USERS U ON DPR.USER_ID=U.ID JOIN PROFILE_INFO P ON P.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID  WHERE  F.PRIM_BANK_NAME NOT LIKE '%HDFC%' AND  DEP_ID = ? ORDER BY U.EMP_ID,CLIENT_NAME";
		
	 if(flagBank.equals("HDFC")){
         stmt = conn.prepareStatement(SQL_HDFC);
     }else{
         stmt = conn.prepareStatement(SQL_NON_HDFC);
     }
	 
	 stmt.setMaxRows(maxRows);
     stmt.setObject(1,id);
     // bind parameters
     
     rs = stmt.executeQuery();
     // fetch the results
     Collection<DepPerdiemReport> resultList = new ArrayList<DepPerdiemReport>();
     
     while (rs.next()){
         DepPerdiemReport dto = new DepPerdiemReport();
         populateDto1(dto, rs);
         resultList.add(dto);
     }
     DepPerdiemReport ret[]=new DepPerdiemReport[resultList.size()];
     resultList.toArray(ret);
     return ret;
	 
	 
	 }		
	 catch (Exception _e){
         logger.error("Exception: " + _e.getMessage(), _e);
         throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
     } finally{
         ResourceManager.close(rs);
         ResourceManager.close(stmt);
         if (!isConnSupplied){
             ResourceManager.close(conn);
         }
     }
		
	}
	@Override
	public String updateAllReceivedPay(int id, ArrayList<Integer> ddp_id,
			String flag) throws DepPerdiemReportDaoException {
		 // declare variables
        final boolean isConnSupplied = (userConn != null);
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try{
        	
        	  conn = isConnSupplied ? userConn : ResourceManager.getConnection();
              


              int retval = ddp_id.size();
              int count=1;
              StringBuilder builder = new StringBuilder();
              for( int i = 0 ; i < retval; i++ ) {
                  if(count<retval){
                      builder.append("?,");
                      count++;
                  }else{
                      builder.append("?");
                  }
              
              }
              String sql="UPDATE DEP_PERDIEM_REPORT SET PAID=? WHERE DEP_ID=? AND ID IN("+builder+") ";
              int i=3;
             
              stmt = conn.prepareStatement(sql);
              stmt.setObject(1, "paid");
              stmt.setObject(2, id);
              for(i=3;i<ddp_id.size()+3;i++){
                  stmt.setObject(i,ddp_id.get(i-3));    
              }
              int affectedrow=stmt.executeUpdate();
              return "Successfully updated";
        	
        	
        	
        }
		
        catch (Exception _e){
            logger.error("Exception: " + _e.getMessage(), _e);
            throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
        } finally{
            ResourceManager.close(rs);
            ResourceManager.close(stmt);
            if (!isConnSupplied){
                ResourceManager.close(conn);
            }
        }
	}

	
@Override
public List<String[]> findInternalReportData(int id) throws DepPerdiemReportDaoException {

		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			
			final String SQL = "SELECT EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME, CLIENT_NAME, PERDIEM, CURRENCY_TYPE, PAYABLE_DAYS, TOTAL, PERDIEM_FROM, PERDIEM_TO, (CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_ACC_NO ELSE F.PRIM_BANK_ACC_NO END) AS ACC_NO,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME FROM DEP_PERDIEM_REPORT DR JOIN USERS U ON DR.USER_ID = U.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID WHERE DEP_ID=? AND TYPE NOT IN ("
					+ ReconciliationModel.DELETED + "," + ReconciliationModel.FIXED_DELETED + "," + ReconciliationModel.HOLD + "," + ReconciliationModel.FIXED_HOLD + ") ORDER BY CLIENT_NAME,EMP_ID";
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, id);
			rs = stmt.executeQuery();
			List<String[]> resultList = new ArrayList<String[]>();
			Map<String, String> currencyTypes = CurrencyDaoFactory.create(conn).getAllCurrencyTypes();
			while (rs.next()){
				String[] row = new String[11];
				row[0] = rs.getInt(1) + "";
				row[1] = rs.getString(2);
				row[2] = rs.getString(3);
				row[3] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(4))));
				String currencyName = currencyTypes.get(rs.getInt(5) + "");
				row[4] = currencyName == null ? rs.getInt(5) + "" : currencyName;
				row[5] = rs.getFloat(6) + "";
				row[6] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(7))));
				row[7] = PortalUtility.getdd_MM_yyyy(rs.getDate(8));
				row[8] = PortalUtility.getdd_MM_yyyy(rs.getDate(9));;
				row[9] = rs.getString(10);
				row[10] = rs.getString(11);
				resultList.add(row);
			}
			return resultList;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
	

	
	
	@Override
	public List<String[]> findInternalReportDataNONHDFC(int id,
			ArrayList<Integer> arraylist) throws DepPerdiemReportDaoException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
	
			int retval = arraylist.size();
			int count=1;
			StringBuilder builder = new StringBuilder();
			for( int i = 0 ; i < retval; i++ ) {
				if(count<retval){
				    builder.append("?,");
					count++;
				}else{
					builder.append("?");
				}
			
			}
			try{
	            String sql="UPDATE DEP_PERDIEM_REPORT SET PAID=? WHERE DEP_ID=? AND ID IN("+builder+") ";
	            int i=3;
	           
	            stmt = conn.prepareStatement(sql);
	            stmt.setObject(1, "un paid");
	            stmt.setObject(2,id);
	            for(i=3;i<arraylist.size()+3;i++){
	                stmt.setObject(i,arraylist.get(i-3));    
	            }
	            int affectedrow=stmt.executeUpdate();
	            logger.debug("PAID STATUS UPDATED IN DEP_PERDIEM_REPORT ROW AFFECTED"+affectedrow);
	            
	        }catch(SQLException e){
	            e.printStackTrace();
	        }
		//	final String accNoSql = ", (CASE ACCOUNT_TYPE WHEN 0 THEN F.PRIM_BANK_ACC_NO WHEN 1 THEN F.PRIM_BANK_ACC_NO WHEN 2 THEN F.SEC_BANK_ACC_NO END) AS BANK_ACC_NO";
	//		final String bankNameSql = ", (CASE ACCOUNT_TYPE WHEN 0 THEN F.PRIM_BANK_NAME WHEN 1 THEN F.PRIM_BANK_NAME WHEN 2 THEN F.SEC_BANK_NAME END) AS BANK_NAME";
			


		/*	
			final String SQL = "SELECT U.EMP_ID AS ID,CONCAT(PF.FIRST_NAME,' ',PF.LAST_NAME) AS NAME, CLIENT_NAME, PERDIEM, CURRENCY_TYPE, PAYABLE_DAYS, TOTAL, PERDIEM_FROM, PERDIEM_TO, (CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_ACC_NO ELSE F.PRIM_BANK_ACC_NO END) AS ACC_NO,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME,PF.OFFICAL_EMAIL_ID,BD.IFCI_NUMBER FROM DEP_PERDIEM_REPORT DR JOIN USERS U ON DR.USER_ID = U.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID LEFT JOIN BANK_DETAILS BD ON BD.BANK_NAME=F.PRIM_BANK_NAME  WHERE DEP_ID=? AND DR.ID IN("+builder+") AND  F.PRIM_BANK_NAME NOT LIKE '%HDFC%'  AND TYPE NOT IN ("
					+ ReconciliationModel.DELETED + "," + ReconciliationModel.FIXED_DELETED + "," + ReconciliationModel.HOLD + "," + ReconciliationModel.FIXED_HOLD + ") ORDER BY CLIENT_NAME,EMP_ID";
			*/
			
			
			final String SQL = "SELECT U.EMP_ID AS ID,CONCAT(PF.FIRST_NAME,' ',PF.LAST_NAME) AS NAME, CLIENT_NAME, PERDIEM, CURRENCY_TYPE, PAYABLE_DAYS, TOTAL, PERDIEM_FROM, PERDIEM_TO, (CASE ACCOUNT_TYPE WHEN 0 THEN F.PRIM_BANK_ACC_NO WHEN 1 THEN F.PRIM_BANK_ACC_NO WHEN 2 THEN F.SEC_BANK_ACC_NO END) AS BANK_ACC_NO,(CASE ACCOUNT_TYPE WHEN 0 THEN F.PRIM_BANK_NAME WHEN 1 THEN F.PRIM_BANK_NAME WHEN 2 THEN F.SEC_BANK_NAME END) AS BANK_NAME,PF.OFFICAL_EMAIL_ID,F.PRIMARY_IFSC_CODE FROM DEP_PERDIEM_REPORT DR JOIN USERS U ON DR.USER_ID = U.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID   WHERE DEP_ID=? AND DR.ID IN("+builder+") AND  F.PRIM_BANK_NAME NOT LIKE '%HDFC%'  AND TYPE NOT IN ("
					+ ReconciliationModel.DELETED + "," + ReconciliationModel.FIXED_DELETED + "," + ReconciliationModel.HOLD + "," + ReconciliationModel.FIXED_HOLD + ") ORDER BY U.ID";
			
			
			stmt = conn.prepareStatement(SQL);
			
			
			stmt.setMaxRows(maxRows);
			int i=2;
			stmt.setObject(1, id);
			for(i=2;i<arraylist.size()+2;i++){
				stmt.setObject(i,arraylist.get(i-2));	
			//	System.out.println("2");
			}
			rs = stmt.executeQuery();
			List<String[]> resultList = new ArrayList<String[]>();
			Map<String, String> currencyTypes = CurrencyDaoFactory.create(conn).getAllCurrencyTypes();
			while (rs.next()){
				String[] row = new String[14];
				row[0] = rs.getInt(1) + "";
				row[1] = rs.getString(2);
				row[2] = rs.getString(3);
				row[3] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(4))));
				String currencyName = currencyTypes.get(rs.getInt(5) + "");
				row[4] = currencyName == null ? rs.getInt(5) + "" : currencyName;
				row[5] = rs.getFloat(6) + "";
				row[6] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(7))));
				row[7] = PortalUtility.getdd_MM_yyyy(rs.getDate(8));
				row[8] = PortalUtility.getdd_MM_yyyy(rs.getDate(9));;
				row[9] = rs.getString(10);//acc no
				row[10] = rs.getString(11); // bank name
				//row[11]=rs.getString(12);
				// change part
				row[11] = rs.getString(12);
				row[12] = rs.getString(13);
				row[13] = PortalUtility.getTodayDate();
				
		
				
				resultList.add(row);
			}
			return resultList;
			} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
		
	}
	@Override
	public List<String[]> findInternalReportDataHDFC(int id,
			ArrayList<Integer> arraylist) throws DepPerdiemReportDaoException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		;
		try{
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			int retval = arraylist.size();
			int count=1;
			StringBuilder builder = new StringBuilder();
			for( int i = 0 ; i < retval; i++ ) {
				if(count<retval){
				    builder.append("?,");
					count++;
				}else{
					builder.append("?");
				}
			
			}
		     try{
		            String sql="UPDATE DEP_PERDIEM_REPORT SET PAID=? WHERE DEP_ID=? AND ID IN("+builder+") ";
		            int i=3;
		            
		            stmt = conn.prepareStatement(sql);
		            stmt.setObject(1, "un paid");
		            stmt.setObject(2,id);
		            for(i=3;i<arraylist.size()+3;i++){
		                stmt.setObject(i,arraylist.get(i-3));    
		            }
		            int affectedrow=stmt.executeUpdate();
		            logger.debug("PAID STATUS UPDATED IN DEP_PERDIEM_REPORT ROW AFFECTED"+affectedrow);
		            
		        }catch(SQLException e){
		            e.printStackTrace();
		        }
			
			
			
			
					
			final String SQL = "SELECT U.EMP_ID AS ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME, CLIENT_NAME, PERDIEM, CURRENCY_TYPE, PAYABLE_DAYS, TOTAL, PERDIEM_FROM, PERDIEM_TO, (CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_ACC_NO ELSE F.PRIM_BANK_ACC_NO END) AS ACC_NO,(CASE WHEN F.PRIM_BANK_ACC_NO IS NULL THEN F.SEC_BANK_NAME ELSE F.PRIM_BANK_NAME END) AS BANK_NAME,PF.OFFICAL_EMAIL_ID,BD.IFCI_NUMBER,BD.BRANCH FROM DEP_PERDIEM_REPORT DR JOIN USERS U ON DR.USER_ID = U.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID LEFT JOIN BANK_DETAILS BD ON BD.BANK_NAME=F.PRIM_BANK_NAME  WHERE DEP_ID=? AND DR.ID IN("+builder+") AND  F.PRIM_BANK_NAME LIKE '%HDFC%'  AND TYPE NOT IN ("
					+ ReconciliationModel.DELETED + "," + ReconciliationModel.FIXED_DELETED + "," + ReconciliationModel.HOLD + "," + ReconciliationModel.FIXED_HOLD + ") ORDER BY U.ID";
			
			
			stmt = conn.prepareStatement(SQL);
			
						
			
			stmt.setMaxRows(maxRows);
			int i=2;
			stmt.setObject(1, id);
			for(i=2;i<arraylist.size()+2;i++){
				stmt.setObject(i,arraylist.get(i-2));	
				
			}
			rs = stmt.executeQuery();
			List<String[]> resultList = new ArrayList<String[]>();
			Map<String, String> currencyTypes = CurrencyDaoFactory.create(conn).getAllCurrencyTypes();
			while (rs.next()){
				String[] row = new String[15];
				row[0] = rs.getInt(1) + "";
				row[1] = rs.getString(2);
				row[2] = rs.getString(3);
				row[3] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(4))));
				String currencyName = currencyTypes.get(rs.getInt(5) + "");
				row[4] = currencyName == null ? rs.getInt(5) + "" : currencyName;
				row[5] = rs.getFloat(6) + "";
				row[6] = new DecimalFormat("0.00").format(Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(7))));
				row[7] = PortalUtility.getdd_MM_yyyy(rs.getDate(8));
				row[8] = PortalUtility.getdd_MM_yyyy(rs.getDate(9));;
				row[9] = rs.getString(10);
				row[10] = rs.getString(11);
				//row[11]=rs.getString(12);
				// change part
				row[11] = rs.getString(12);
				row[12] = rs.getString(13);
				row[13] = rs.getString(14);
				row[14] = PortalUtility.getTodayDate();
	
				
				resultList.add(row);
			}
			return resultList;
			} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
		
	
	} 

	public List<PerdiemReportBean> findBankReport(int id, int flag) throws DepPerdiemReportDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			final String ACC_NO_SQL = ", (CASE ACCOUNT_TYPE WHEN 0 THEN (CASE WHEN F.SEC_BANK_ACC_NO IS NULL OR F.SEC_BANK_ACC_NO ='' THEN F.PRIM_BANK_ACC_NO ELSE F.SEC_BANK_ACC_NO END) WHEN 1 THEN F.PRIM_BANK_ACC_NO WHEN 2 THEN F.SEC_BANK_ACC_NO END) AS ACC_NO";
			final String BANK_NAME_SQL = ", (CASE ACCOUNT_TYPE WHEN 0 THEN (CASE WHEN F.SEC_BANK_ACC_NO IS NULL OR F.SEC_BANK_ACC_NO ='' THEN F.PRIM_BANK_NAME ELSE F.SEC_BANK_NAME END) WHEN 1 THEN F.PRIM_BANK_NAME WHEN 2 THEN F.SEC_BANK_NAME END) AS BANK_NAME";
			final String SQL = "SELECT EMP_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME, TOTAL " + ACC_NO_SQL + BANK_NAME_SQL + " FROM DEP_PERDIEM_REPORT DR JOIN USERS U ON DR.USER_ID = U.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID WHERE DEP_ID=? AND TYPE NOT IN ("
					+ ReconciliationModel.DELETED + "," + ReconciliationModel.FIXED_DELETED + "," + ReconciliationModel.FIXED_HOLD + "," + ReconciliationModel.FIXED_REJECTED + "," + ReconciliationModel.HOLD + "," + ReconciliationModel.REJECTED + "," + ReconciliationModel.ADDED_DELETED + ") ORDER BY EMP_ID";
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, id);
			rs = stmt.executeQuery();
			List<PerdiemReportBean> resultList = new ArrayList<PerdiemReportBean>();
			Map<String, PerdiemReportBean> map = new HashMap<String, PerdiemReportBean>();
			while (rs.next()){
				String empId = rs.getInt(1) + "";
				String bankName = rs.getString(5);
				if ((flag == 1 && bankName != null && bankName.toUpperCase().contains("ICICI")) || (flag != 1 && (bankName == null || !bankName.toUpperCase().contains("ICICI")))){
					if (map.containsKey(empId)){
						PerdiemReportBean record = map.get(empId);
						record.setTotal(record.getTotal() + (int) Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(3))));
						map.put(empId, record);
					} else{
						map.put(empId, new PerdiemReportBean(empId, rs.getString(4), (int) Double.parseDouble(DesEncrypterDecrypter.getInstance().decrypt(rs.getString(3))), rs.getString(5), rs.getString(2)));
					}
				}
			}
			for (Map.Entry<String, PerdiemReportBean> entry : map.entrySet()){
				PerdiemReportBean p = entry.getValue();
				if (p.getTotal() > 0) resultList.add(p);
			}
			Collections.sort(resultList);
			return resultList;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new DepPerdiemReportDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	@Override
	public DepPerdiemReport[] findByUserID(String sql, Object[] sqlParams) throws DepPerdiemReqDaoException {
		// TODO Auto-generated method stub
/*		Collection<DepPerdiemReq> resultList = new ArrayList<DepPerdiemReq>();
		while (rs.next()) {
			DepPerdiemReq dto = new DepPerdiemReq();
			populateDto( dto, rs);
			resultList.add( dto );*/
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			Collection<DepPerdiemReport> resultList = new ArrayList<DepPerdiemReport>();
			while (rs.next()) {
				DepPerdiemReport dto = new DepPerdiemReport();
				populateDto1( dto, rs);
				resultList.add( dto );
			}
			DepPerdiemReport ret[] = new DepPerdiemReport[ resultList.size() ];
			resultList.toArray( ret );
			return ret;
			/*SalaryReconciliationReport ret[] = new SalaryReconciliationReport[resultList.size()];
			resultList.toArray(ret);
			return ret;*/
		} catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new DepPerdiemReqDaoException( "Exception: " + _e.getMessage(), _e );
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	

	

	
}
	

	