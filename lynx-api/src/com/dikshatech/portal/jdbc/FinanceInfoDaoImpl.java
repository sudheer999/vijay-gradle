/*
 * This source file was generated by FireStorm/DAO.
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * For more information please visit http://www.codefutures.com/products/firestorm
 */
package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;

import com.dikshatech.common.utils.DesEncrypterDecrypter;
import com.dikshatech.common.utils.JDBCUtiility;
import com.dikshatech.portal.dao.FinanceInfoDao;
import com.dikshatech.portal.dao.MonthlyPayrollDao;
import com.dikshatech.portal.dao.SalaryReconciliationReportDao;
import com.dikshatech.portal.dto.FinanceInfo;
import com.dikshatech.portal.dto.FinanceInfoPk;
import com.dikshatech.portal.dto.MonthlyPayroll;
import com.dikshatech.portal.dto.SalaryReconciliation;
import com.dikshatech.portal.dto.SalaryReconciliationReport;
import com.dikshatech.portal.exceptions.FinanceInfoDaoException;
import com.dikshatech.portal.exceptions.MonthlyPayrollDaoException;
import com.dikshatech.portal.exceptions.SalaryReconciliationReportDaoException;
import com.dikshatech.portal.factory.MonthlyPayrollDaoFactory;
import com.dikshatech.portal.factory.SalaryReconciliationReportDaoFactory;
import com.dikshatech.portal.models.FBPModel;

public class FinanceInfoDaoImpl extends AbstractDAO implements FinanceInfoDao {

	/**
	 * The factory class for this DAO has two versions of the create() method - one that
	 * takes no arguments and one that takes a Connection argument. If the Connection version
	 * is chosen then the connection will be stored in this attribute and will be used by all
	 * calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection	userConn;
	protected static final Logger	logger					= Logger.getLogger(FinanceInfoDaoImpl.class);
	/**
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String			SQL_SELECT				= "SELECT ID, PF_ACC_NO, PAN_NO, CTC, PRIM_BANK_ACC_NO, PRIM_BANK_NAME, SEC_BANK_ACC_NO, SEC_BANK_NAME, SALARY_DETAIL, MODIFIED_BY,SALARY_CYCLE,PRIMARY_IFSC_CODE,SECONDARY_IFSC_CODE,UAN,AADHAAR_NO FROM " + getTableName() + "";
	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int					maxRows;
	/**
	 * SQL INSERT statement for this table
	 */
	protected final String			SQL_INSERT				= "INSERT INTO " + getTableName() + " ( ID, PF_ACC_NO, PAN_NO, CTC, PRIM_BANK_ACC_NO, PRIM_BANK_NAME, SEC_BANK_ACC_NO, SEC_BANK_NAME, SALARY_DETAIL, MODIFIED_BY,SALARY_CYCLE,PRIMARY_IFSC_CODE,SECONDARY_IFSC_CODE,UAN,AADHAAR_NO ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?, ?, ?,?,? )";
	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String			SQL_UPDATE				= "UPDATE " + getTableName() + " SET ID = ?, PF_ACC_NO = ?, PAN_NO = ?, CTC = ?, PRIM_BANK_ACC_NO = ?, PRIM_BANK_NAME = ?, SEC_BANK_ACC_NO = ?, SEC_BANK_NAME = ?, SALARY_DETAIL = ?, MODIFIED_BY= ? ,SALARY_CYCLE=?, PRIMARY_IFSC_CODE = ?, SECONDARY_IFSC_CODE = ?, UAN = ?, AADHAAR_NO = ? WHERE ID = ?";
	/**
	 * SQL DELETE statement for this table
	 */
	protected final String			SQL_DELETE				= "DELETE FROM " + getTableName() + " WHERE ID = ?";
	/**
	 * Index of column ID
	 */
	protected static final int		COLUMN_ID				= 1;
	/**
	 * Index of column PF_ACC_NO
	 */
	protected static final int		COLUMN_PF_ACC_NO		= 2;
	/**
	 * Index of column PAN_NO
	 */
	protected static final int		COLUMN_PAN_NO			= 3;
	/**
	 * Index of column CTC
	 */
	protected static final int		COLUMN_CTC				= 4;
	/**
	 * Index of column PRIM_BANK_ACC_NO
	 */
	protected static final int		COLUMN_PRIM_BANK_ACC_NO	= 5;
	/**
	 * Index of column PRIM_BANK_NAME
	 */
	protected static final int		COLUMN_PRIM_BANK_NAME	= 6;
	/**
	 * Index of column SEC_BANK_ACC_NO
	 */
	protected static final int		COLUMN_SEC_BANK_ACC_NO	= 7;
	/**
	 * Index of column SEC_BANK_NAME
	 */
	protected static final int		COLUMN_SEC_BANK_NAME	= 8;
	/**
	 * Index of column SALARY_DETAIL
	 */
	protected static final int		COLUMN_SALARY_DETAIL	= 9;
	/**
	 * Index of column MODIFIED_BY
	 */
	protected static final int		COLUMN_MODIFIED_BY	= 10;
	
	/**
	 * Index of column SALARY_CYCLE
	 */
	protected static final int		COLUMN_SALARY_CYCLE = 11;
	/**
	 * Index of column PRIMARY_IFSC_CODE
	 * 
	 */
	protected static final int 		COLUMN_PRIMARY_IFSC_CODE=12;
	/**
	 * Indec of column SECONDARY_IFSC_CODE
	 * 
	 */
	protected static final int 		COLUMN_SECONDARY_IFSC_CODE = 13;
	/**
	 * Indec of column SECONDARY_IFSC_CODE
	 * 
	 */
	protected static final int 		COLUMN_UAN = 14;
	/**
	 * Indec of column SECONDARY_IFSC_CODE
	 * 
	 */
	protected static final int 		COLUMN_AADHAAR_NO = 15;
	/**
	 * Number of columns
	 */
	//protected static final int		NUMBER_OF_COLUMNS		= 10;
	//protected static final int		NUMBER_OF_COLUMNS		= 11;
	protected static final int		NUMBER_OF_COLUMNS		= 15;
	/**
	 * Index of primary-key column ID
	 */
	protected static final int		PK_COLUMN_ID			= 1;

	/**
	 * Inserts a new row in the FINANCE_INFO table.
	 */
	public FinanceInfoPk insert(FinanceInfo dto) throws FinanceInfoDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			stmt = conn.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setString(index++, dto.getPfAccNo());
			stmt.setString(index++, dto.getPanNo());
			stmt.setString(index++, dto.getCtc());
			stmt.setString(index++, dto.getPrimBankAccNo());
			stmt.setString(index++, dto.getPrimBankName());
			stmt.setString(index++, dto.getSecBankAccNo());
			stmt.setString(index++, dto.getSecBankName());
			stmt.setString(index++, dto.getSalaryDetail());
			stmt.setInt(index++, dto.getModifiedBy());
			stmt.setString(index++, dto.getSalaryCycle());
			stmt.setString(index++, dto.getPrimaryifsc());
			stmt.setString(index++, dto.getSecondaryifsccode());
			stmt.setString(index++, dto.getUan());
			stmt.setString(index++, dto.getAadhaarNo());
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()){
				dto.setId(rs.getInt(1));
			}
			reset(dto);
			return dto.createPk();
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Updates a single row in the FINANCE_INFO table.
	 */
	public void update(FinanceInfoPk pk, FinanceInfo dto) throws FinanceInfoDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setString(index++, dto.getPfAccNo());
			stmt.setString(index++, dto.getPanNo());
			stmt.setString(index++, dto.getCtc());
			stmt.setString(index++, dto.getPrimBankAccNo());
			stmt.setString(index++, dto.getPrimBankName());
			stmt.setString(index++, dto.getSecBankAccNo());
			stmt.setString(index++, dto.getSecBankName());
			stmt.setString(index++, dto.getSalaryDetail());
			stmt.setInt(index++, dto.getModifiedBy());
			stmt.setString(index++, dto.getSalaryCycle());
			stmt.setString(index++, dto.getPrimaryifsc());
			stmt.setString(index++, dto.getSecondaryifsccode());
			stmt.setString(index++, dto.getUan());
			stmt.setString(index++, dto.getAadhaarNo());
			//stmt.setInt(11, pk.getId());
			//stmt.setInt(12, pk.getId());
			stmt.setInt(16, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Deletes a single row in the FINANCE_INFO table.
	 */
	public void delete(FinanceInfoPk pk) throws FinanceInfoDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}
			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns the rows from the FINANCE_INFO table that matches the specified primary-key value.
	 */
	public FinanceInfo findByPrimaryKey(FinanceInfoPk pk) throws FinanceInfoDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'ID = :id'.
	 */
	public FinanceInfo findByPrimaryKey(int id) throws FinanceInfoDaoException {
		FinanceInfo ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?", new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria ''.
	 */
	public FinanceInfo[] findAll() throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " ORDER BY ID", null);
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'ID = :id'.
	 */
	public FinanceInfo[] findWhereIdEquals(int id) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ID = ? ORDER BY ID", new Object[] { new Integer(id) });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'PF_ACC_NO = :pfAccNo'.
	 */
	public FinanceInfo[] findWherePfAccNoEquals(String pfAccNo) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PF_ACC_NO = ? ORDER BY PF_ACC_NO", new Object[] { pfAccNo });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'PAN_NO = :panNo'.
	 */
	public FinanceInfo[] findWherePanNoEquals(String panNo) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PAN_NO = ? ORDER BY PAN_NO", new Object[] { panNo });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'CTC = :ctc'.
	 */
	public FinanceInfo[] findWhereCtcEquals(String ctc) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE CTC = ? ORDER BY CTC", new Object[] { ctc });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'PRIM_BANK_ACC_NO = :primBankAccNo'.
	 */
	public FinanceInfo[] findWherePrimBankAccNoEquals(String primBankAccNo) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PRIM_BANK_ACC_NO = ? ORDER BY PRIM_BANK_ACC_NO", new Object[] { primBankAccNo });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'PRIM_BANK_NAME = :primBankName'.
	 */
	public FinanceInfo[] findWherePrimBankNameEquals(String primBankName) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PRIM_BANK_NAME = ? ORDER BY PRIM_BANK_NAME", new Object[] { primBankName });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'SEC_BANK_ACC_NO = :secBankAccNo'.
	 */
	public FinanceInfo[] findWhereSecBankAccNoEquals(String secBankAccNo) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE SEC_BANK_ACC_NO = ? ORDER BY SEC_BANK_ACC_NO", new Object[] { secBankAccNo });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'SEC_BANK_NAME = :secBankName'.
	 */
	public FinanceInfo[] findWhereSecBankNameEquals(String secBankName) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE SEC_BANK_NAME = ? ORDER BY SEC_BANK_NAME", new Object[] { secBankName });
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the criteria 'SALARY_DETAIL = :salaryDetail'.
	 */
	public FinanceInfo[] findWhereSalaryDetailEquals(String salaryDetail) throws FinanceInfoDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE SALARY_DETAIL = ? ORDER BY SALARY_DETAIL", new Object[] { salaryDetail });
	}

	/**
	 * Method 'FinanceInfoDaoImpl'
	 */
	public FinanceInfoDaoImpl() {}

	/**
	 * Method 'FinanceInfoDaoImpl'
	 * 
	 * @param userConn
	 */
	public FinanceInfoDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName() {
		return "FINANCE_INFO";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected FinanceInfo fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()){
			FinanceInfo dto = new FinanceInfo();
			populateDto(dto, rs);
			return dto;
		} else{
			return null;
		}
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected FinanceInfo[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<FinanceInfo> resultList = new ArrayList<FinanceInfo>();
		while (rs.next()){
			FinanceInfo dto = new FinanceInfo();
			populateDto(dto, rs);
			resultList.add(dto);
		}
		FinanceInfo ret[] = new FinanceInfo[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(FinanceInfo dto, ResultSet rs) throws SQLException {
		dto.setId(rs.getInt(COLUMN_ID));
		dto.setPfAccNo(rs.getString(COLUMN_PF_ACC_NO));
		dto.setPanNo(rs.getString(COLUMN_PAN_NO));
		dto.setCtc(rs.getString(COLUMN_CTC));
		dto.setPrimBankAccNo(rs.getString(COLUMN_PRIM_BANK_ACC_NO));
		dto.setPrimBankName(rs.getString(COLUMN_PRIM_BANK_NAME));
		dto.setSecBankAccNo(rs.getString(COLUMN_SEC_BANK_ACC_NO));
		dto.setSecBankName(rs.getString(COLUMN_SEC_BANK_NAME));
		dto.setModifiedBy(rs.getInt(COLUMN_MODIFIED_BY));
		dto.setSalaryCycle(rs.getString(COLUMN_SALARY_CYCLE));
		dto.setPrimaryifsc(rs.getString(COLUMN_PRIMARY_IFSC_CODE));
		dto.setSecondaryifsccode(rs.getString(COLUMN_SECONDARY_IFSC_CODE));
		dto.setAadhaarNo(rs.getString(COLUMN_AADHAAR_NO));
		dto.setUan(rs.getString(COLUMN_UAN));
		

	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(FinanceInfo dto) {}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the specified arbitrary SQL statement
	 */
	public FinanceInfo[] findByDynamicSelect(String sql, Object[] sqlParams) throws FinanceInfoDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the specified arbitrary SQL statement
	 */
	public FinanceInfo[] findByDynamicWhere(String sql, Object[] sqlParams) throws FinanceInfoDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the FINANCE_INFO table that match the specified arbitrary SQL statement
	 */
	public FinanceInfo findByUserId(int userId) throws FinanceInfoDaoException {
		// declare variables
		if (userId <= 0) return null;
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			final String SQL = "SELECT F.* FROM FINANCE_INFO F JOIN USERS U ON U.FINANCE_ID=F.ID WHERE U.ID=?";
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, userId);
			rs = stmt.executeQuery();
			FinanceInfo[] infos = fetchMultiResults(rs);
			return infos != null && infos.length > 0 ? infos[0] : null;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new FinanceInfoDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
	
	// new field code added here (SalaryAdvToBeDeducted) by venkat
	@Override
	public void updateSalaryInAdv(String[] values) {
		if (values == null || values.length != 7 || values[0] == null) return;
		try{
			if (values[1] == null || values[2] == null){
				JDBCUtiility.getInstance().update("DELETE FROM SALARY_IN_ADVANCE WHERE ID=?", new Object[] { values[0] });
			} else if (JDBCUtiility.getInstance().getRowCount("FROM SALARY_IN_ADVANCE WHERE ID=?", new Object[] { values[0] }) > 0){
				JDBCUtiility.getInstance().update("UPDATE SALARY_IN_ADVANCE SET TOTAL=?, MONTHLY=?, NUMBER_OF_MONTHS=?, BALANCE_AMOUNT=?, PAID_AMOUNT=?, DEDUCTION_STATUS=? WHERE ID=?", new Object[] { values[1], values[2], values[3], values[4], values[5],values[6], values[0] });
			} else{
				JDBCUtiility.getInstance().update("INSERT INTO SALARY_IN_ADVANCE (ID, TOTAL, MONTHLY, NUMBER_OF_MONTHS,  BALANCE_AMOUNT, PAID_AMOUNT,DEDUCTION_STATUS) VALUES (?, ?, ?, ?, ?, ?,?)", new Object[] { values[0], values[1], values[2], values[3], values[4], values[5], values[6] });
			}
		} catch (Exception e){
			logger.error("Unable to update Salary In Advance for : " + values);
		}
	}

	/**
	 * @param user_id
	 * @return returns salary in advance from SALARY_IN_ADVANCE table in folloing format String[]{ID, TOTAL, MONTHLY}
	 */
	@Override
	public String[] getSalaryInAdv(int user_id) {
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// new field code added here (SalaryAdvToBeDeducted) by venkat
			
			// get the user-specified connection or get a connection from the ResourceManager
			conn = ResourceManager.getConnection();
			final String SQL = "SELECT ID, TOTAL, MONTHLY, NUMBER_OF_MONTHS, BALANCE_AMOUNT, PAID_AMOUNT, DEDUCTION_STATUS FROM SALARY_IN_ADVANCE WHERE ID=?";
			// construct the SQL statement
			if (logger.isDebugEnabled()) logger.debug("Executing " + SQL);
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			// bind parameters
			stmt.setObject(1, user_id);
			rs = stmt.executeQuery();
			// fetch the results
			if (rs.next()){ return new String[] { rs.getInt(1) + "", rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6), rs.getString(7)};}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			_e.printStackTrace();
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			ResourceManager.close(conn);
		}
		return null;
	}
	
	
	public void updateSalaryInAdvance(SalaryReconciliation reconciliation){
		 MonthlyPayrollDao monthlyPayrollDao=MonthlyPayrollDaoFactory.create();
		 SalaryReconciliationReportDao reportDao=SalaryReconciliationReportDaoFactory.create();
		String monthId = FBPModel.getMonthId();
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		String[] advance=null;
		SalaryReconciliationReport[] report=null;
		float amount=0;
		float totAmount=0;
		float balAmount=0;
		float paidAmount=0;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			
			conn = ResourceManager.getConnection();
			report=reportDao.findByDynamicWhere("SR_ID=?", new Object[]{ reconciliation.getId()});
			if(report!=null){
			for(SalaryReconciliationReport eachReport:report){
			MonthlyPayroll[] payroll=monthlyPayrollDao.findByDynamicWhere("USERID=? AND MONTHID=?", new Object[]{eachReport.getUserId(),monthId});
			for(MonthlyPayroll pay:payroll){
			if(pay.getComponent().equalsIgnoreCase("Salary in Advance")){
				 
				amount=Float.valueOf(DesEncrypterDecrypter.getInstance().decrypt(pay.getAmount()));
			 }	
			 }	
			          if(amount>0){
				          advance=getSalaryInAdv(eachReport.getUserId());
				          if(advance!=null){
					        totAmount=Float.valueOf(advance[1]);
					        balAmount=Float.valueOf(advance[4]);
					        paidAmount=Float.valueOf(advance[5])+amount;
					        balAmount=balAmount-amount;
					        updateSalaryInAdv(new String[] { eachReport.getUserId() + "", String.valueOf(totAmount), advance[2] ,advance[3],String.valueOf(balAmount),String.valueOf(paidAmount)});	
				          }
					}
			}
			}	
		} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		catch (MonthlyPayrollDaoException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch (SalaryReconciliationReportDaoException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			ResourceManager.close(conn);
		}
		}
	
	
//travel advance code start here and written by venkat
	@Override
	public void updateTravelInAdv(String[] values) {
		if( values == null || values.length !=7 || values[0] == null) return;
		try {
			if(values[1] == null || values[2] == null) {
				JDBCUtiility.getInstance().update("DELETE FROM TRAVEL_ADVANCE WHERE USER_ID=?", new Object[] { values[0] });
			}else if(JDBCUtiility.getInstance().getRowCount("FROM TRAVEL_ADVANCE WHERE USER_ID=?", new Object[] {values[0]}) > 0) {
					JDBCUtiility.getInstance().update("UPDATE TRAVEL_ADVANCE SET TOTAL=?, MONTHLY=?, NUMBER_OF_MONTHS=?, BALANCE_AMOUNT=?, PAID_AMOUNT=? ,DEDUCTION_STATUS=? WHERE USER_ID=?", new Object[] { values[1], values[2], values[3], values[4], values[5],values[6], values[0] });
				} else{
					JDBCUtiility.getInstance().update("INSERT INTO TRAVEL_ADVANCE (USER_ID, TOTAL, MONTHLY, NUMBER_OF_MONTHS,  BALANCE_AMOUNT, PAID_AMOUNT, DEDUCTION_STATUS) VALUES (?, ?, ?, ?, ?, ?, ?)", new Object[] {values[0], values[1], values[2], values[3], values[4], values[5], values[6]});
				}
			
		}catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	
	
	
	@Override
	public String[] getTravelInAdv(int user_id) {
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			conn=ResourceManager.getConnection();
			final String SQL="SELECT USER_ID, TOTAL, MONTHLY, NUMBER_OF_MONTHS, BALANCE_AMOUNT, PAID_AMOUNT, DEDUCTION_STATUS FROM TRAVEL_ADVANCE WHERE USER_ID=?";
			if(logger.isDebugEnabled()) logger.debug("Executing" +SQL);
			stmt=conn.prepareStatement(SQL);
			stmt.setObject(1, user_id);
			rs=stmt.executeQuery();
			if(rs.next()) {
				return new String[] {rs.getString(1)+"",rs.getInt(2)+"",rs.getString(3), rs.getString(4), rs.getString(5) , rs.getString(6),rs.getString(7)};
				}
			
				
		}catch (Exception _e) {
			logger.error("Exception" + _e.getMessage(), _e);
			_e.printStackTrace();
			
		}finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			ResourceManager.close(conn);
		}
		return null;
	}

	@Override
	public void updateTravelInAdvance(SalaryReconciliation reconciliation) {
		
		
	}

	
}