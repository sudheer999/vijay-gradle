/*
 * This source file was generated by FireStorm/DAO.
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * For more information please visit http://www.codefutures.com/products/firestorm
 */
package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import org.apache.log4j.Logger;
import com.dikshatech.portal.dao.InboxDao;
import com.dikshatech.portal.dto.Inbox;
import com.dikshatech.portal.dto.InboxPk;
import com.dikshatech.portal.exceptions.InboxDaoException;

public class InboxDaoImpl extends AbstractDAO implements InboxDao {

	/**
	 * The factory class for this DAO has two versions of the create() method -
	 * one that takes no arguments and one that takes a Connection argument. If
	 * the Connection version is chosen then the connection will be stored in
	 * this attribute and will be used by all calls to this DAO, otherwise a new
	 * Connection will be allocated for each operation.
	 */
	protected java.sql.Connection	userConn;
	protected static final Logger	logger						= Logger.getLogger(InboxDaoImpl.class);
	//protected final String			ASSIGNED_TO					= "(SELECT FIRST_NAME FROM PROFILE_INFO PF LEFT JOIN USERS U ON U.PROFILE_ID = PF.ID WHERE U.ID = ASSIGNED_TO) AS ASSIGNED_NAME";
	protected static final String	ASSIGNED_TO					= "(SELECT FIRST_NAME FROM PROFILE_INFO PF LEFT JOIN USERS U ON U.PROFILE_ID = PF.ID WHERE U.ID = (SELECT ASSIGNED_TO FROM EMP_SER_REQ_HISTORY ESRQ WHERE ESRQ.ID=(SELECT MAX(ESRQH.ID) FROM EMP_SER_REQ_HISTORY ESRQH WHERE ESRQH.ESR_MAP_ID=I.ESR_MAP_ID))) AS ASSIGNED_NAME";
	protected static final String	RAISED_BY					= "(SELECT FIRST_NAME FROM PROFILE_INFO PF LEFT JOIN USERS U ON U.PROFILE_ID = PF.ID WHERE U.ID = RAISED_BY) AS RAISED_BY_NAME";
	protected static final String	REQ_NAME					= "(SELECT REQ_ID FROM EMP_SER_REQ_MAP ESR WHERE ESR.ID = ESR_MAP_ID) AS REQUEST_ID";
	public static final String		SQL_SELECT_WITHOUT_BODY		= "SELECT ID, RECEIVER_ID, ESR_MAP_ID, SUBJECT, ASSIGNED_TO, RAISED_BY, CREATION_DATETIME, DUE_DATE, STATUS, CATEGORY, IS_READ, IS_DELETED, null AS MESSAGE_BODY, " + ASSIGNED_TO + ", " + RAISED_BY + ", " + REQ_NAME + ", IS_ESCALATED FROM " + getTableName() + " I ";
	/**
	 * All finder methods in this class use this SELECT constant to build their
	 * queries
	 */
	protected final String			SQL_SELECT					= "SELECT ID, RECEIVER_ID, ESR_MAP_ID, SUBJECT, ASSIGNED_TO, RAISED_BY, CREATION_DATETIME, DUE_DATE, STATUS, CATEGORY, IS_READ, IS_DELETED, MESSAGE_BODY, " + ASSIGNED_TO + ", " + RAISED_BY + ", " + REQ_NAME + ", IS_ESCALATED FROM " + getTableName() + " I ";
	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int					maxRows;
	/**
	 * SQL INSERT statement for this table
	 */
	protected final String			SQL_INSERT					= "INSERT INTO " + getTableName() + " ( RECEIVER_ID, ESR_MAP_ID, SUBJECT, ASSIGNED_TO, RAISED_BY, CREATION_DATETIME, DUE_DATE, STATUS, CATEGORY, IS_READ, IS_DELETED, MESSAGE_BODY, IS_ESCALATED ) VALUES (  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String			SQL_UPDATE					= "UPDATE " + getTableName() + " SET ID = ?, RECEIVER_ID = ?, ESR_MAP_ID = ?, SUBJECT = ?, ASSIGNED_TO = ?, RAISED_BY = ?, CREATION_DATETIME = ?, DUE_DATE = ?, STATUS = ?, CATEGORY = ?, IS_READ = ?, IS_DELETED = ?, MESSAGE_BODY = ?, IS_ESCALATED = ? WHERE ID = ?";
	/**
	 * SQL DELETE statement for this table
	 */
	protected final String			SQL_DELETE					= "DELETE FROM " + getTableName() + " WHERE ID = ?";
	/**
	 * Index of column ID
	 */
	protected static final int		COLUMN_ID					= 1;
	/**
	 * Index of column RECEIVER_ID
	 */
	protected static final int		COLUMN_RECEIVER_ID			= 2;
	/**
	 * Index of column ESR_MAP_ID
	 */
	protected static final int		COLUMN_ESR_MAP_ID			= 3;
	/**
	 * Index of column SUBJECT
	 */
	protected static final int		COLUMN_SUBJECT				= 4;
	/**
	 * Index of column ASSIGNED_TO
	 */
	protected static final int		COLUMN_ASSIGNED_TO			= 5;
	/**
	 * Index of column RAISED_BY
	 */
	protected static final int		COLUMN_RAISED_BY			= 6;
	/**
	 * Index of column CREATION_DATETIME
	 */
	protected static final int		COLUMN_CREATION_DATETIME	= 7;
	/**
	 * Index of column DUE_DATE
	 */
	protected static final int		COLUMN_DUE_DATE				= 8;
	/**
	 * Index of column STATUS
	 */
	protected static final int		COLUMN_STATUS				= 9;
	/**
	 * Index of column CATEGORY
	 */
	protected static final int		COLUMN_CATEGORY				= 10;
	/**
	 * Index of column IS_READ
	 */
	protected static final int		COLUMN_IS_READ				= 11;
	/**
	 * Index of column IS_DELETED
	 */
	protected static final int		COLUMN_IS_DELETED			= 12;
	/**
	 * Index of column MESSAGE_BODY
	 */
	protected static final int		COLUMN_MESSAGE_BODY			= 13;
	/**
	 * Below columns are joined
	 */
	
	
	/**
	 * Index of column ASSIGNED_NAME
	 */
	protected static final int		COLUMN_ASSIGNED_NAME		= 14;
	/**
	 * Index of column RAISED_BY_NAME
	 */
	protected static final int		COLUMN_RAISED_BY_NAME		= 15;
	/**
	 * Index of column REQUEST_ID
	 */
	protected static final int		COLUMN_REQUEST_ID			= 16;
	/**
	 * Number of columns
	 */

	/** 
	 * Index of column IS_ESCALATED
	 */
	protected static final int COLUMN_IS_ESCALATED = 17;

	
	protected static final int		NUMBER_OF_COLUMNS			= 14;
	/**
	 * Index of primary-key column ID
	 */
	protected static final int		PK_COLUMN_ID				= 1;

	/**
	 * Inserts a new row in the INBOX table.
	 */
	public InboxPk insert(Inbox dto) throws InboxDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			stmt = conn.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			// stmt.setInt( index++, dto.getId() );
			stmt.setInt(index++, dto.getReceiverId());
			if (dto.isEsrMapIdNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getEsrMapId());
			}
			stmt.setString(index++, dto.getSubject());
			if (dto.isAssignedToNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedTo());
			}
			if (dto.isRaisedByNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getRaisedBy());
			}
			stmt.setTimestamp(index++, dto.getCreationDatetime() == null ? null : new java.sql.Timestamp(dto.getCreationDatetime().getTime()));
			stmt.setDate(index++, dto.getDueDate() == null ? null : new java.sql.Date(dto.getDueDate().getTime()));
			stmt.setString(index++, dto.getStatus());
			stmt.setString(index++, dto.getCategory());
			stmt.setInt(index++, dto.getIsRead());
			stmt.setInt(index++, dto.getIsDeleted());
			stmt.setString(index++, dto.getMessageBody());

			if (dto.isIsEscalatedNull()) {
				stmt.setNull( index++, java.sql.Types.INTEGER );
			} else {
				stmt.setInt( index++, dto.getIsEscalated() );
			}
			
			
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}
			int rows = stmt.executeUpdate();
			//InboxCountAdapter.invokeUser(dto.getReceiverId());
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()){
				dto.setId(rs.getInt(1));
			}
			reset(dto);
			return dto.createPk();
		} catch (Exception _e){
			_e.printStackTrace();
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Updates a single row in the INBOX table.
	 */
	public void update(InboxPk pk, Inbox dto) throws InboxDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setInt(index++, dto.getReceiverId());
			if (dto.isEsrMapIdNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getEsrMapId());
			}
			stmt.setString(index++, dto.getSubject());
			if (dto.isAssignedToNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedTo());
			}
			if (dto.isRaisedByNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getRaisedBy());
			}
			stmt.setTimestamp(index++, dto.getCreationDatetime() == null ? null : new java.sql.Timestamp(dto.getCreationDatetime().getTime()));
			stmt.setDate(index++, dto.getDueDate() == null ? null : new java.sql.Date(dto.getDueDate().getTime()));
			stmt.setString(index++, dto.getStatus());
			stmt.setString(index++, dto.getCategory());
			stmt.setInt(index++, dto.getIsRead());
			stmt.setInt(index++, dto.getIsDeleted());
			stmt.setString(index++, dto.getMessageBody());
			
			if (dto.isIsEscalatedNull()) {
				stmt.setNull( index++, java.sql.Types.INTEGER );
			} else {
				stmt.setInt( index++, dto.getIsEscalated() );
			}


			stmt.setInt(index, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Deletes a single row in the INBOX table.
	 */
	public void delete(InboxPk pk) throws InboxDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}
			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns the rows from the INBOX table that matches the specified
	 * primary-key value.
	 */
	public Inbox findByPrimaryKey(InboxPk pk) throws InboxDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'ID = :id'.
	 */
	public Inbox findByPrimaryKey(int id) throws InboxDaoException {
		Inbox ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?", new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria ''.
	 */
	public Inbox[] findAll() throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " ORDER BY ID", null);
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'ID = :id'.
	 */
	public Inbox[] findWhereIdEquals(int id) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ID = ? ORDER BY ID", new Object[] { new Integer(id) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria
	 * 'RECEIVER_ID = :receiverId'.
	 */
	public Inbox[] findWhereReceiverIdEquals(int receiverId) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE RECEIVER_ID = ? ORDER BY RECEIVER_ID", new Object[] { new Integer(receiverId) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'ESR_MAP_ID
	 * = :esrMapId'.
	 */
	public Inbox[] findWhereEsrMapIdEquals(int esrMapId) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ESR_MAP_ID = ? ORDER BY ESR_MAP_ID", new Object[] { new Integer(esrMapId) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'SUBJECT =
	 * :subject'.
	 */
	public Inbox[] findWhereSubjectEquals(String subject) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE SUBJECT = ? ORDER BY SUBJECT", new Object[] { subject });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria
	 * 'ASSIGNED_TO = :assignedTo'.
	 */
	public Inbox[] findWhereAssignedToEquals(int assignedTo) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ASSIGNED_TO = ? ORDER BY ASSIGNED_TO", new Object[] { new Integer(assignedTo) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'RAISED_BY
	 * = :raisedBy'.
	 */
	public Inbox[] findWhereRaisedByEquals(int raisedBy) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE RAISED_BY = ? ORDER BY RAISED_BY", new Object[] { new Integer(raisedBy) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria
	 * 'CREATION_DATETIME = :creationDatetime'.
	 */
	public Inbox[] findWhereCreationDatetimeEquals(Date creationDatetime) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE CREATION_DATETIME = ? ORDER BY CREATION_DATETIME", new Object[] { creationDatetime == null ? null : new java.sql.Timestamp(creationDatetime.getTime()) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'DUE_DATE =
	 * :dueDate'.
	 */
	public Inbox[] findWhereDueDateEquals(Date dueDate) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE DUE_DATE = ? ORDER BY DUE_DATE", new Object[] { dueDate == null ? null : new java.sql.Date(dueDate.getTime()) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'STATUS =
	 * :status'.
	 */
	public Inbox[] findWhereStatusEquals(String status) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE STATUS = ? ORDER BY STATUS", new Object[] { status });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'CATEGORY =
	 * :category'.
	 */
	public Inbox[] findWhereCategoryEquals(String category) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE CATEGORY = ? ORDER BY CATEGORY", new Object[] { category });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'IS_READ =
	 * :isRead'.
	 */
	public Inbox[] findWhereIsReadEquals(short isRead) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE IS_READ = ? ORDER BY IS_READ", new Object[] { new Short(isRead) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'IS_DELETED
	 * = :isDeleted'.
	 */
	public Inbox[] findWhereIsDeletedEquals(short isDeleted) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE IS_DELETED = ? ORDER BY IS_DELETED", new Object[] { new Short(isDeleted) });
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria
	 * 'MESSAGE_BODY = :messageBody'.
	 */
	public Inbox[] findWhereMessageBodyEquals(String messageBody) throws InboxDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE MESSAGE_BODY = ? ORDER BY MESSAGE_BODY", new Object[] { messageBody });
	}

	/** 
	 * Returns all rows from the INBOX table that match the criteria 'IS_ESCALATED = :isEscalated'.
	 */
	public Inbox[] findWhereIsEscalatedEquals(int isEscalated) throws InboxDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE IS_ESCALATED = ? ORDER BY IS_ESCALATED", new Object[] {  new Integer(isEscalated) } );
	}

	
	/**
	 * Method 'InboxDaoImpl'
	 */
	public InboxDaoImpl() {}

	/**
	 * Method 'InboxDaoImpl'
	 * 
	 * @param userConn
	 */
	public InboxDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public static String getTableName() {
		return "INBOX";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected Inbox fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()){
			Inbox dto = new Inbox();
			populateDto(dto, rs);
			return dto;
		}
		return null;
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected Inbox[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<Inbox> resultList = new ArrayList<Inbox>();
		while (rs.next()){
			Inbox dto = new Inbox();
			populateDto(dto, rs);
			resultList.add(dto);
		}
		Inbox ret[] = new Inbox[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(Inbox dto, ResultSet rs) throws SQLException {
		dto.setId(rs.getInt(COLUMN_ID));
		dto.setReceiverId(rs.getInt(COLUMN_RECEIVER_ID));
		dto.setEsrMapId(rs.getInt(COLUMN_ESR_MAP_ID));
		if (rs.wasNull()){
			dto.setEsrMapIdNull(true);
		}
		dto.setSubject(rs.getString(COLUMN_SUBJECT));
		dto.setAssignedTo(rs.getInt(COLUMN_ASSIGNED_TO));
		if (rs.wasNull()){
			dto.setAssignedToNull(true);
		}
		dto.setRaisedBy(rs.getInt(COLUMN_RAISED_BY));
		if (rs.wasNull()){
			dto.setRaisedByNull(true);
		}
		dto.setCreationDatetime(rs.getTimestamp(COLUMN_CREATION_DATETIME));
		dto.setDueDate(rs.getDate(COLUMN_DUE_DATE));
		dto.setStatus(rs.getString(COLUMN_STATUS));
		dto.setCategory(rs.getString(COLUMN_CATEGORY));
		dto.setIsRead(rs.getShort(COLUMN_IS_READ));
		dto.setIsDeleted(rs.getShort(COLUMN_IS_DELETED));
		dto.setMessageBody(rs.getString(COLUMN_MESSAGE_BODY));
		dto.setAssignedToName(rs.getString(COLUMN_ASSIGNED_NAME));
		dto.setRaisedByName(rs.getString(COLUMN_RAISED_BY_NAME));
		dto.setReqName(rs.getString(COLUMN_REQUEST_ID));
		dto.setIsEscalated( rs.getInt( COLUMN_IS_ESCALATED ) );
		if (rs.wasNull()) {
			dto.setIsEscalatedNull( true );
		}

	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(Inbox dto) {}

	/**
	 * Returns all rows from the INBOX table that match the specified arbitrary
	 * SQL statement
	 */
	public Inbox[] findByDynamicSelect(String sql, Object[] sqlParams) throws InboxDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the INBOX table that match the specified arbitrary
	 * SQL statement
	 */
	public Inbox[] findByDynamicWhere(String sql, Object[] sqlParams) throws InboxDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	public void executeUpdate(String sql) throws InboxDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.executeUpdate();
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new InboxDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the INBOX table that match the criteria 'SELECT
	 * COUNT(*) FROM INBOX WHERE RECEIVER_ID = :receiverId AND IS_READ = 0'.
	 */
	public static void main(String[] args) throws Exception {}
}
