/*
 * This source file was generated by FireStorm/DAO.
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * For more information please visit http://www.codefutures.com/products/firestorm
 */
package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;

import org.apache.log4j.Logger;

import com.dikshatech.beans.LeaveMasterBean;
import com.dikshatech.common.utils.PortalUtility;
import com.dikshatech.portal.dao.LeaveMasterDao;
import com.dikshatech.portal.dto.LeaveMaster;
import com.dikshatech.portal.dto.LeaveMasterPk;
import com.dikshatech.portal.exceptions.LeaveMasterDaoException;

public class LeaveMasterDaoImpl extends AbstractDAO implements LeaveMasterDao {

	/**
	 * The factory class for this DAO has two versions of the create() method - one that
	 * takes no arguments and one that takes a Connection argument. If the Connection version
	 * is chosen then the connection will be stored in this attribute and will be used by all
	 * calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection	userConn;
	protected static final Logger	logger						= Logger.getLogger(LeaveMasterDaoImpl.class);
	/**
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String			SQL_SELECT					= "SELECT ID, ESR_MAP_ID, LEAVE_TYPE, CONTACT_NO, FROM_DATE, TO_DATE, DURATION, APPLIED_DATE_TIME, APPROVED_DATE_TIME, REASON, COMMENT, UUID, ATTACHMENT, ASSIGNED_TO, STATUS, ASSIGNED_TO_DIVISION, TO_CANCELL, ACTION_BY, MESSAGE_BODY, SERVED, PROJECT_NAME, PROJECT_TITLE, REMARK, ISLWP FROM " + getTableName() + "";
	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int					maxRows;
	/**
	 * SQL INSERT statement for this table
	 */
	protected final String			SQL_INSERT					= "INSERT INTO " + getTableName() + " ( ID, ESR_MAP_ID, LEAVE_TYPE, CONTACT_NO, FROM_DATE, TO_DATE, DURATION, APPLIED_DATE_TIME, APPROVED_DATE_TIME, REASON, COMMENT, UUID, ATTACHMENT, ASSIGNED_TO, STATUS, ASSIGNED_TO_DIVISION, TO_CANCELL, ACTION_BY, MESSAGE_BODY, SERVED, PROJECT_NAME, PROJECT_TITLE, REMARK, ISLWP ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )";
	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String			SQL_UPDATE					= "UPDATE " + getTableName() + " SET ID = ?, ESR_MAP_ID = ?, LEAVE_TYPE = ?, CONTACT_NO = ?, FROM_DATE = ?, TO_DATE = ?, DURATION = ?, APPLIED_DATE_TIME = ?, APPROVED_DATE_TIME = ?, REASON = ?, COMMENT = ?, UUID = ?, ATTACHMENT = ?, ASSIGNED_TO = ?, STATUS = ?, ASSIGNED_TO_DIVISION = ?, TO_CANCELL = ?, ACTION_BY = ?, MESSAGE_BODY = ?, SERVED = ?, PROJECT_NAME = ?, PROJECT_TITLE = ?, REMARK = ?, ISLWP = ? WHERE ID = ?";
	/**
	 * SQL DELETE statement for this table
	 */
	protected final String			SQL_DELETE					= "DELETE FROM " + getTableName() + " WHERE ID = ?";
	/**
	 * Index of column ID
	 */
	protected static final int		COLUMN_ID					= 1;
	/**
	 * Index of column ESR_MAP_ID
	 */
	protected static final int		COLUMN_ESR_MAP_ID			= 2;
	/**
	 * Index of column LEAVE_TYPE
	 */
	protected static final int		COLUMN_LEAVE_TYPE			= 3;
	/**
	 * Index of column CONTACT_NO
	 */
	protected static final int		COLUMN_CONTACT_NO			= 4;
	/**
	 * Index of column FROM_DATE
	 */
	protected static final int		COLUMN_FROM_DATE			= 5;
	/**
	 * Index of column TO_DATE
	 */
	protected static final int		COLUMN_TO_DATE				= 6;
	/**
	 * Index of column DURATION
	 */
	protected static final int		COLUMN_DURATION				= 7;
	/**
	 * Index of column APPLIED_DATE_TIME
	 */
	protected static final int		COLUMN_APPLIED_DATE_TIME	= 8;
	/**
	 * Index of column APPROVED_DATE_TIME
	 */
	protected static final int		COLUMN_APPROVED_DATE_TIME	= 9;
	/**
	 * Index of column REASON
	 */
	protected static final int		COLUMN_REASON				= 10;
	/**
	 * Index of column COMMENT
	 */
	protected static final int		COLUMN_COMMENT				= 11;
	/**
	 * Index of column UUID
	 */
	protected static final int		COLUMN_UUID					= 12;
	/**
	 * Index of column ATTACHMENT
	 */
	protected static final int		COLUMN_ATTACHMENT			= 13;
	/**
	 * Index of column ASSIGNED_TO
	 */
	protected static final int		COLUMN_ASSIGNED_TO			= 14;
	/**
	 * Index of column STATUS
	 */
	protected static final int		COLUMN_STATUS				= 15;
	/**
	 * Index of column ASSIGNED_TO_DIVISION
	 */
	protected static final int		COLUMN_ASSIGNED_TO_DIVISION	= 16;
	/**
	 * Index of column TO_CANCELL
	 */
	protected static final int		COLUMN_TO_CANCELL			= 17;
	/**
	 * Index of column ACTION_BY
	 */
	protected static final int		COLUMN_ACTION_BY			= 18;
	/**
	 * Index of column MESSAGE_BODY
	 */
	protected static final int		COLUMN_MESSAGE_BODY			= 19;
	/**
	 * Index of column SERVED
	 */
	protected static final int		COLUMN_SERVED				= 20;
	/**
	 * Index of column PROJECT_NAME
	 */
	protected static final int		COLUMN_PROJECT_NAME			= 21;
	/**
	 * Index of column PROJECT_TITLE
	 */
	protected static final int		COLUMN_PROJECT_TITLE		= 22;
	/**
	 * Index of column REMARK
	 */
	protected static final int		COLUMN_REMARK				= 23;
	/**
	 * Index of column ISLWP
	 */
	protected static final int		COLUMN_ISLWP				= 24;
	/**
	 * Number of columns
	 */
	protected static final int		NUMBER_OF_COLUMNS			= 24;
	/**
	 * Index of primary-key column ID
	 */
	protected static final int		PK_COLUMN_ID				= 1;

	/**
	 * Inserts a new row in the LEAVE_MASTER table.
	 */
	public LeaveMasterPk insert(LeaveMaster dto) throws LeaveMasterDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			stmt = conn.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			if (dto.isEsrMapIdNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getEsrMapId());
			}
			if (dto.isLeaveTypeNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getLeaveType());
			}
			stmt.setString(index++, dto.getContactNo());
			stmt.setDate(index++, dto.getFromDate() == null ? null : new java.sql.Date(dto.getFromDate().getTime()));
			stmt.setDate(index++, dto.getToDate() == null ? null : new java.sql.Date(dto.getToDate().getTime()));
			if (dto.isDurationNull()){
				stmt.setNull(index++, java.sql.Types.FLOAT);
			} else{
				stmt.setFloat(index++, dto.getDuration());
			}
			stmt.setTimestamp(index++, dto.getAppliedDateTime() == null ? null : new java.sql.Timestamp(dto.getAppliedDateTime().getTime()));
			stmt.setTimestamp(index++, dto.getApprovedDateTime() == null ? null : new java.sql.Timestamp(dto.getApprovedDateTime().getTime()));
			stmt.setString(index++, dto.getReason());
			stmt.setString(index++, dto.getComment());
			stmt.setString(index++, dto.getUuid());
			stmt.setString(index++, dto.getAttachment());
			if (dto.isAssignedToNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedTo());
			}
			stmt.setString(index++, dto.getStatus());
			if (dto.isAssignedToDivisionNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedToDivision());
			}
			if (dto.isToCancellNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getToCancell());
			}
			if (dto.isActionByNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getActionBy());
			}
			stmt.setString(index++, dto.getMessageBody());
			if (dto.isServedNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setShort(index++, dto.getServed());
			}
			stmt.setString(index++, dto.getProjectName());
			stmt.setString(index++, dto.getProjectTitle());
			stmt.setString(index++, dto.getRemark());
			stmt.setFloat(index++, dto.getIslwp());
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()){
				dto.setId(rs.getInt(1));
			}
			reset(dto);
			return dto.createPk();
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Updates a single row in the LEAVE_MASTER table.
	 */
	public void update(LeaveMasterPk pk, LeaveMaster dto) throws LeaveMasterDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			if (dto.isEsrMapIdNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getEsrMapId());
			}
			if (dto.isLeaveTypeNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getLeaveType());
			}
			stmt.setString(index++, dto.getContactNo());
			stmt.setDate(index++, dto.getFromDate() == null ? null : new java.sql.Date(dto.getFromDate().getTime()));
			stmt.setDate(index++, dto.getToDate() == null ? null : new java.sql.Date(dto.getToDate().getTime()));
			if (dto.isDurationNull()){
				stmt.setNull(index++, java.sql.Types.FLOAT);
			} else{
				stmt.setFloat(index++, dto.getDuration());
			}
			stmt.setTimestamp(index++, dto.getAppliedDateTime() == null ? null : new java.sql.Timestamp(dto.getAppliedDateTime().getTime()));
			stmt.setTimestamp(index++, dto.getApprovedDateTime() == null ? null : new java.sql.Timestamp(dto.getApprovedDateTime().getTime()));
			stmt.setString(index++, dto.getReason());
			stmt.setString(index++, dto.getComment());
			stmt.setString(index++, dto.getUuid());
			stmt.setString(index++, dto.getAttachment());
			if (dto.isAssignedToNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedTo());
			}
			stmt.setString(index++, dto.getStatus());
			if (dto.isAssignedToDivisionNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getAssignedToDivision());
			}
			if (dto.isToCancellNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getToCancell());
			}
			if (dto.isActionByNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setInt(index++, dto.getActionBy());
			}
			stmt.setString(index++, dto.getMessageBody());
			if (dto.isServedNull()){
				stmt.setNull(index++, java.sql.Types.INTEGER);
			} else{
				stmt.setShort(index++, dto.getServed());
			}
			stmt.setString(index++, dto.getProjectName());
			stmt.setString(index++, dto.getProjectTitle());
			stmt.setString(index++, dto.getRemark());
			stmt.setFloat(index++, dto.getIslwp());
			stmt.setInt(25, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Deletes a single row in the LEAVE_MASTER table.
	 */
	public void delete(LeaveMasterPk pk) throws LeaveMasterDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}
			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns the rows from the LEAVE_MASTER table that matches the specified primary-key value.
	 */
	public LeaveMaster findByPrimaryKey(LeaveMasterPk pk) throws LeaveMasterDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ID = :id'.
	 */
	public LeaveMaster findByPrimaryKey(int id) throws LeaveMasterDaoException {
		LeaveMaster ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?", new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria ''.
	 */
	public LeaveMaster[] findAll() throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " ORDER BY ID", null);
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ID = :id'.
	 */
	public LeaveMaster[] findWhereIdEquals(int id) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ID = ? ORDER BY ID", new Object[] { new Integer(id) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ESR_MAP_ID = :esrMapId'.
	 */
	public LeaveMaster[] findWhereEsrMapIdEquals(int esrMapId) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ESR_MAP_ID = ? ORDER BY ESR_MAP_ID", new Object[] { new Integer(esrMapId) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'LEAVE_TYPE = :leaveType'.
	 */
	public LeaveMaster[] findWhereLeaveTypeEquals(int leaveType) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE LEAVE_TYPE = ? ORDER BY LEAVE_TYPE", new Object[] { new Integer(leaveType) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'CONTACT_NO = :contactNo'.
	 */
	public LeaveMaster[] findWhereContactNoEquals(String contactNo) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE CONTACT_NO = ? ORDER BY CONTACT_NO", new Object[] { contactNo });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'FROM_DATE = :fromDate'.
	 */
	public LeaveMaster[] findWhereFromDateEquals(Date fromDate) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE FROM_DATE = ? ORDER BY FROM_DATE", new Object[] { fromDate == null ? null : new java.sql.Date(fromDate.getTime()) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'TO_DATE = :toDate'.
	 */
	public LeaveMaster[] findWhereToDateEquals(Date toDate) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE TO_DATE = ? ORDER BY TO_DATE", new Object[] { toDate == null ? null : new java.sql.Date(toDate.getTime()) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'DURATION = :duration'.
	 */
	public LeaveMaster[] findWhereDurationEquals(float duration) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE DURATION = ? ORDER BY DURATION", new Object[] { new Float(duration) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'APPLIED_DATE_TIME = :appliedDateTime'.
	 */
	public LeaveMaster[] findWhereAppliedDateTimeEquals(Date appliedDateTime) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE APPLIED_DATE_TIME = ? ORDER BY APPLIED_DATE_TIME", new Object[] { appliedDateTime == null ? null : new java.sql.Timestamp(appliedDateTime.getTime()) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'APPROVED_DATE_TIME = :approvedDateTime'.
	 */
	public LeaveMaster[] findWhereApprovedDateTimeEquals(Date approvedDateTime) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE APPROVED_DATE_TIME = ? ORDER BY APPROVED_DATE_TIME", new Object[] { approvedDateTime == null ? null : new java.sql.Timestamp(approvedDateTime.getTime()) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'REASON = :reason'.
	 */
	public LeaveMaster[] findWhereReasonEquals(String reason) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE REASON = ? ORDER BY REASON", new Object[] { reason });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'COMMENT = :comment'.
	 */
	public LeaveMaster[] findWhereCommentEquals(String comment) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE COMMENT = ? ORDER BY COMMENT", new Object[] { comment });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'UUID = :uuid'.
	 */
	public LeaveMaster[] findWhereUuidEquals(String uuid) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE UUID = ? ORDER BY UUID", new Object[] { uuid });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ATTACHMENT = :attachment'.
	 */
	public LeaveMaster[] findWhereAttachmentEquals(String attachment) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ATTACHMENT = ? ORDER BY ATTACHMENT", new Object[] { attachment });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ASSIGNED_TO = :assignedTo'.
	 */
	public LeaveMaster[] findWhereAssignedToEquals(int assignedTo) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ASSIGNED_TO = ? ORDER BY ASSIGNED_TO", new Object[] { new Integer(assignedTo) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'STATUS = :status'.
	 */
	public LeaveMaster[] findWhereStatusEquals(String status) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE STATUS = ? ORDER BY STATUS", new Object[] { status });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ASSIGNED_TO_DIVISION = :assignedToDivision'.
	 */
	public LeaveMaster[] findWhereAssignedToDivisionEquals(int assignedToDivision) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ASSIGNED_TO_DIVISION = ? ORDER BY ASSIGNED_TO_DIVISION", new Object[] { new Integer(assignedToDivision) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'TO_CANCELL = :toCancell'.
	 */
	public LeaveMaster[] findWhereToCancellEquals(int toCancell) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE TO_CANCELL = ? ORDER BY TO_CANCELL", new Object[] { new Integer(toCancell) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ACTION_BY = :actionBy'.
	 */
	public LeaveMaster[] findWhereActionByEquals(int actionBy) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ACTION_BY = ? ORDER BY ACTION_BY", new Object[] { new Integer(actionBy) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'MESSAGE_BODY = :messageBody'.
	 */
	public LeaveMaster[] findWhereMessageBodyEquals(String messageBody) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE MESSAGE_BODY = ? ORDER BY MESSAGE_BODY", new Object[] { messageBody });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'SERVED = :served'.
	 */
	public LeaveMaster[] findWhereServedEquals(short served) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE SERVED = ? ORDER BY SERVED", new Object[] { new Short(served) });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'PROJECT_NAME = :projectName'.
	 */
	public LeaveMaster[] findWhereProjectNameEquals(String projectName) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PROJECT_NAME = ? ORDER BY PROJECT_NAME", new Object[] { projectName });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'PROJECT_TITLE = :projectTitle'.
	 */
	public LeaveMaster[] findWhereProjectTitleEquals(String projectTitle) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PROJECT_TITLE = ? ORDER BY PROJECT_TITLE", new Object[] { projectTitle });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'REMARK = :remark'.
	 */
	public LeaveMaster[] findWhereRemarkEquals(String remark) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE REMARK = ? ORDER BY REMARK", new Object[] { remark });
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the criteria 'ISLWP = :islwp'.
	 */
	public LeaveMaster[] findWhereIslwpEquals(float islwp) throws LeaveMasterDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ISLWP = ? ORDER BY ISLWP", new Object[] { new Float(islwp) });
	}

	/**
	 * Method 'LeaveMasterDaoImpl'
	 */
	public LeaveMasterDaoImpl() {}

	/**
	 * Method 'LeaveMasterDaoImpl'
	 * 
	 * @param userConn
	 */
	public LeaveMasterDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName() {
		return "LEAVE_MASTER";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected LeaveMaster fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()){
			LeaveMaster dto = new LeaveMaster();
			populateDto(dto, rs);
			return dto;
		} else{
			return null;
		}
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected LeaveMaster[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<LeaveMaster> resultList = new ArrayList<LeaveMaster>();
		while (rs.next()){
			LeaveMaster dto = new LeaveMaster();
			populateDto(dto, rs);
			resultList.add(dto);
		}
		LeaveMaster ret[] = new LeaveMaster[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(LeaveMaster dto, ResultSet rs) throws SQLException {
		dto.setId(rs.getInt(COLUMN_ID));
		dto.setEsrMapId(rs.getInt(COLUMN_ESR_MAP_ID));
		if (rs.wasNull()){
			dto.setEsrMapIdNull(true);
		}
		dto.setLeaveType(rs.getInt(COLUMN_LEAVE_TYPE));
		if (rs.wasNull()){
			dto.setLeaveTypeNull(true);
		}
		dto.setContactNo(rs.getString(COLUMN_CONTACT_NO));
		dto.setFromDate(rs.getDate(COLUMN_FROM_DATE));
		dto.setToDate(rs.getDate(COLUMN_TO_DATE));
		dto.setDuration(rs.getFloat(COLUMN_DURATION));
		if (rs.wasNull()){
			dto.setDurationNull(true);
		}
		dto.setAppliedDateTime(rs.getTimestamp(COLUMN_APPLIED_DATE_TIME));
		dto.setApprovedDateTime(rs.getTimestamp(COLUMN_APPROVED_DATE_TIME));
		dto.setReason(rs.getString(COLUMN_REASON));
		dto.setComment(rs.getString(COLUMN_COMMENT));
		dto.setUuid(rs.getString(COLUMN_UUID));
		dto.setAttachment(rs.getString(COLUMN_ATTACHMENT));
		dto.setAssignedTo(rs.getInt(COLUMN_ASSIGNED_TO));
		if (rs.wasNull()){
			dto.setAssignedToNull(true);
		}
		dto.setStatus(rs.getString(COLUMN_STATUS));
		dto.setAssignedToDivision(rs.getInt(COLUMN_ASSIGNED_TO_DIVISION));
		if (rs.wasNull()){
			dto.setAssignedToDivisionNull(true);
		}
		dto.setToCancell(rs.getInt(COLUMN_TO_CANCELL));
		if (rs.wasNull()){
			dto.setToCancellNull(true);
		}
		dto.setActionBy(rs.getInt(COLUMN_ACTION_BY));
		if (rs.wasNull()){
			dto.setActionByNull(true);
		}
		dto.setMessageBody(rs.getString(COLUMN_MESSAGE_BODY));
		dto.setServed(rs.getShort(COLUMN_SERVED));
		if (rs.wasNull()){
			dto.setServedNull(true);
		}
		dto.setProjectName(rs.getString(COLUMN_PROJECT_NAME));
		dto.setProjectTitle(rs.getString(COLUMN_PROJECT_TITLE));
		dto.setRemark(rs.getString(COLUMN_REMARK));
		dto.setIslwp(rs.getFloat(COLUMN_ISLWP));
	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(LeaveMaster dto) {}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the specified arbitrary SQL statement
	 */
	public LeaveMaster[] findByDynamicSelect(String sql, Object[] sqlParams) throws LeaveMasterDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the LEAVE_MASTER table that match the specified arbitrary SQL statement
	 */
	public LeaveMaster[] findByDynamicWhere(String sql, Object[] sqlParams) throws LeaveMasterDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
			if (logger.isDebugEnabled()) logger.debug("Executing " + SQL);
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	public void dynamicUpdate(String sql, Object[] sqlParams) throws LeaveMasterDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()) logger.debug("Executing " + SQL);
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
		} catch (Exception _e){
			_e.printStackTrace();
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * @author supriya.bhike
	 * @param sql
	 *            select for distinct duration and Esp Map Id
	 * @return arraylist with integer value of ascending with duration distinct
	 */
	public ArrayList<Integer> findByDynamicSelectDuration(String sql, Object[] sqlParams) throws LeaveMasterDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchIntegerArray(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected ArrayList<Integer> fetchIntegerArray(ResultSet rs) throws SQLException {
		ArrayList<Integer> resultList = new ArrayList<Integer>();
		while (rs.next()){
			resultList.add(rs.getInt(1));
		}
		return resultList;
	}

	public LeaveMasterBean[] getLeaveHistory(int userId, int limit) throws LeaveMasterDaoException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = "SELECT FROM_DATE, TO_DATE, DURATION FROM LEAVE_MASTER WHERE ID IN (SELECT MAX(LM.ID) FROM LEAVE_MASTER LM WHERE ESR_MAP_ID IN (SELECT ESRM.ID FROM EMP_SER_REQ_MAP ESRM JOIN SERVICE_REQ_INFO SRI ON ESRM.ID=SRI.ESR_MAP_ID WHERE REQUESTOR_ID = ? AND REQ_TYPE_ID=1 AND REQ_ID NOT LIKE '%CN' AND STATUS IN ('Accepted','Completed')) GROUP BY ESR_MAP_ID) AND YEAR(FROM_DATE)=YEAR(NOW()) ORDER BY ID DESC LIMIT 0,?";
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			stmt.setObject(1, userId);
			stmt.setObject(2, limit);
			rs = stmt.executeQuery();
			// fetch the results
			return fetchLeaveMasterBean(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	private LeaveMasterBean[] fetchLeaveMasterBean(ResultSet rs) throws SQLException {
		ArrayList<LeaveMasterBean> resultList = new ArrayList<LeaveMasterBean>();
		while (rs.next()){
			resultList.add(new LeaveMasterBean(rs.getDate(1), rs.getDate(2), rs.getString(3)));
		}
		return resultList.toArray(new LeaveMasterBean[resultList.size()]);
	}

	public HashMap<String, String> getLeaveHistoryMonthlyCount(int userId) throws LeaveMasterDaoException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = "SELECT MONTH(FROM_DATE), SUM(DURATION) FROM LEAVE_MASTER WHERE ID IN (SELECT MAX(LM.ID) FROM LEAVE_MASTER LM WHERE ESR_MAP_ID IN (SELECT ESRM.ID FROM EMP_SER_REQ_MAP ESRM JOIN SERVICE_REQ_INFO SRI ON ESRM.ID=SRI.ESR_MAP_ID WHERE REQUESTOR_ID = ? AND REQ_TYPE_ID=1 AND REQ_ID NOT LIKE '%CN' AND STATUS IN ('Accepted','Completed')) GROUP BY ESR_MAP_ID) AND YEAR(FROM_DATE)=YEAR(NOW()) GROUP BY MONTH(FROM_DATE)";
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			stmt.setObject(1, userId);
			rs = stmt.executeQuery();
			// fetch the results
			HashMap result = new HashMap<String, String>();
			while (rs.next()){
				result.put(PortalUtility.returnMonth(rs.getInt(1)), rs.getString(2));
			}
			return result;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new LeaveMasterDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
}
