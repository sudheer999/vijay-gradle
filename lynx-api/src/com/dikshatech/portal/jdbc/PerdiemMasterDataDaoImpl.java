/*
 * This source file was generated by FireStorm/DAO.
 * 
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * 
 * For more information please visit http://www.codefutures.com/products/firestorm
 */
package com.dikshatech.portal.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import com.dikshatech.common.utils.DesEncrypterDecrypter;
import com.dikshatech.portal.dao.LeaveLwpDao;
import com.dikshatech.portal.dao.PerdiemMasterDataDao;
import com.dikshatech.portal.dto.Client;
import com.dikshatech.portal.dto.Currency;
import com.dikshatech.portal.dto.DepPerdiemReport;
import com.dikshatech.portal.dto.LeaveLwp;
import com.dikshatech.portal.dto.PerdiemMasterData;
import com.dikshatech.portal.dto.PerdiemMasterDataPk;
import com.dikshatech.portal.exceptions.PerdiemMasterDataDaoException;
import com.dikshatech.portal.factory.ClientDaoFactory;
import com.dikshatech.portal.factory.CurrencyDaoFactory;
import com.dikshatech.portal.factory.LeaveLwpDaoFactory;
import com.dikshatech.portal.models.ReconciliationModel;

public class PerdiemMasterDataDaoImpl extends AbstractDAO implements PerdiemMasterDataDao {

	/**
	 * The factory class for this DAO has two versions of the create() method -
	 * one that takes no arguments and one that takes a Connection argument. If
	 * the Connection version is chosen then the connection will be stored in
	 * this attribute and will be used by all calls to this DAO, otherwise a new
	 * Connection will be allocated for each operation.
	 */
	protected java.sql.Connection	userConn;
	protected static final Logger	logger					= Logger.getLogger(PerdiemMasterDataDaoImpl.class);
	/**
	 * All finder methods in this class use this SELECT constant to build their
	 * queries
	 */
	protected final String			SQL_SELECT				= "SELECT ID, USER_ID, PERDIEM, PERDIEM_FROM, PERDIEM_TO, CURRENCY_TYPE FROM " + getTableName() + "";
	/**
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int					maxRows;
	/**
	 * SQL INSERT statement for this table
	 */
	protected final String			SQL_INSERT				= "INSERT INTO " + getTableName() + " ( ID, USER_ID, PERDIEM, PERDIEM_FROM, PERDIEM_TO, CURRENCY_TYPE ) VALUES ( ?, ?, ?, ?, ?, ? )";
	/**
	 * SQL UPDATE statement for this table
	 */
	protected final String			SQL_UPDATE				= "UPDATE " + getTableName() + " SET ID = ?, USER_ID = ?, PERDIEM = ?, PERDIEM_FROM = ?, PERDIEM_TO = ?, CURRENCY_TYPE = ? WHERE ID = ?";
	/**
	 * SQL DELETE statement for this table
	 */
	protected final String			SQL_DELETE				= "DELETE FROM " + getTableName() + " WHERE ID = ?";
	/**
	 * Index of column ID
	 */
	protected static final int		COLUMN_ID				= 1;
	/**
	 * Index of column USER_ID
	 */
	protected static final int		COLUMN_USER_ID			= 2;
	/**
	 * Index of column PERDIEM
	 */
	protected static final int		COLUMN_PERDIEM			= 3;
	/**
	 * Index of column PERDIEM_FROM
	 */
	protected static final int		COLUMN_PERDIEM_FROM		= 4;
	/**
	 * Index of column PERDIEM_TO
	 */
	protected static final int		COLUMN_PERDIEM_TO		= 5;
	/**
	 * Index of column CURRENCY_TYPE
	 */
	protected static final int		COLUMN_CURRENCY_TYPE	= 6;
	/**
	 * Number of columns
	 */
	protected static final int		NUMBER_OF_COLUMNS		= 6;
	/**
	 * Index of primary-key column ID
	 */
	protected static final int		PK_COLUMN_ID			= 1;

	/**
	 * Inserts a new row in the PERDIEM_MASTER_DATA table.
	 */
	public PerdiemMasterDataPk insert(PerdiemMasterData dto) throws PerdiemMasterDataDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			stmt = conn.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setInt(index++, dto.getUserId());
			stmt.setString(index++, dto.getPerdiem());
			stmt.setDate(index++, dto.getPerdiemFrom() == null ? null : new java.sql.Date(dto.getPerdiemFrom().getTime()));
			stmt.setDate(index++, dto.getPerdiemTo() == null ? null : new java.sql.Date(dto.getPerdiemTo().getTime()));
			stmt.setString(index++, dto.getCurrencyType());
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_INSERT + " with DTO: " + dto);
			}
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()){
				dto.setId(rs.getInt(1));
			}
			reset(dto);
			return dto.createPk();
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Updates a single row in the PERDIEM_MASTER_DATA table.
	 */
	public void update(PerdiemMasterDataPk pk, PerdiemMasterData dto) throws PerdiemMasterDataDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
			stmt = conn.prepareStatement(SQL_UPDATE);
			int index = 1;
			stmt.setInt(index++, dto.getId());
			stmt.setInt(index++, dto.getUserId());
			stmt.setString(index++, dto.getPerdiem());
			stmt.setDate(index++, dto.getPerdiemFrom() == null ? null : new java.sql.Date(dto.getPerdiemFrom().getTime()));
			stmt.setDate(index++, dto.getPerdiemTo() == null ? null : new java.sql.Date(dto.getPerdiemTo().getTime()));
			stmt.setString(index++, dto.getCurrencyType());
			stmt.setInt(7, pk.getId());
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Deletes a single row in the PERDIEM_MASTER_DATA table.
	 */
	public void delete(PerdiemMasterDataPk pk) throws PerdiemMasterDataDaoException {
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL_DELETE + " with PK: " + pk);
			}
			stmt = conn.prepareStatement(SQL_DELETE);
			stmt.setInt(1, pk.getId());
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()){
				logger.debug(rows + " rows affected (" + (t2 - t1) + " ms)");
			}
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns the rows from the PERDIEM_MASTER_DATA table that matches the
	 * specified primary-key value.
	 */
	public PerdiemMasterData findByPrimaryKey(PerdiemMasterDataPk pk) throws PerdiemMasterDataDaoException {
		return findByPrimaryKey(pk.getId());
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'ID = :id'.
	 */
	public PerdiemMasterData findByPrimaryKey(int id) throws PerdiemMasterDataDaoException {
		PerdiemMasterData ret[] = findByDynamicSelect(SQL_SELECT + " WHERE ID = ?", new Object[] { new Integer(id) });
		return ret.length == 0 ? null : ret[0];
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria ''.
	 */
	public PerdiemMasterData[] findAll() throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " ORDER BY ID", null);
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'ID = :id'.
	 */
	public PerdiemMasterData[] findWhereIdEquals(int id) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE ID = ? ORDER BY ID", new Object[] { new Integer(id) });
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'USER_ID = :userId'.
	 */
	public PerdiemMasterData[] findWhereUserIdEquals(int userId) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE USER_ID = ? ORDER BY USER_ID", new Object[] { new Integer(userId) });
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'PERDIEM = :perdiem'.
	 */
	public PerdiemMasterData[] findWherePerdiemEquals(String perdiem) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PERDIEM = ? ORDER BY PERDIEM", new Object[] { perdiem });
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'PERDIEM_FROM = :perdiemFrom'.
	 */
	public PerdiemMasterData[] findWherePerdiemFromEquals(Date perdiemFrom) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PERDIEM_FROM = ? ORDER BY PERDIEM_FROM", new Object[] { perdiemFrom == null ? null : new java.sql.Date(perdiemFrom.getTime()) });
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'PERDIEM_TO = :perdiemTo'.
	 */
	public PerdiemMasterData[] findWherePerdiemToEquals(Date perdiemTo) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE PERDIEM_TO = ? ORDER BY PERDIEM_TO", new Object[] { perdiemTo == null ? null : new java.sql.Date(perdiemTo.getTime()) });
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * criteria 'CURRENCY_TYPE = :currencyType'.
	 */
	public PerdiemMasterData[] findWhereCurrencyTypeEquals(String currencyType) throws PerdiemMasterDataDaoException {
		return findByDynamicSelect(SQL_SELECT + " WHERE CURRENCY_TYPE = ? ORDER BY CURRENCY_TYPE", new Object[] { currencyType });
	}

	/**
	 * Method 'PerdiemMasterDataDaoImpl'
	 * 
	 */
	public PerdiemMasterDataDaoImpl() {}

	/**
	 * Method 'PerdiemMasterDataDaoImpl'
	 * 
	 * @param userConn
	 */
	public PerdiemMasterDataDaoImpl(final java.sql.Connection userConn) {
		this.userConn = userConn;
	}

	/**
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows) {
		this.maxRows = maxRows;
	}

	/**
	 * Gets the value of maxRows
	 */
	public int getMaxRows() {
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName() {
		return "PERDIEM_MASTER_DATA";
	}

	/**
	 * Fetches a single row from the result set
	 */
	protected PerdiemMasterData fetchSingleResult(ResultSet rs) throws SQLException {
		if (rs.next()){
			PerdiemMasterData dto = new PerdiemMasterData();
			populateDto(dto, rs);
			return dto;
		} else{
			return null;
		}
	}

	/**
	 * Fetches multiple rows from the result set
	 */
	protected PerdiemMasterData[] fetchMultiResults(ResultSet rs) throws SQLException {
		Collection<PerdiemMasterData> resultList = new ArrayList<PerdiemMasterData>();
		while (rs.next()){
			PerdiemMasterData dto = new PerdiemMasterData();
			populateDto(dto, rs);
			resultList.add(dto);
		}
		PerdiemMasterData ret[] = new PerdiemMasterData[resultList.size()];
		resultList.toArray(ret);
		return ret;
	}

	/**
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(PerdiemMasterData dto, ResultSet rs) throws SQLException {
		dto.setId(rs.getInt(COLUMN_ID));
		dto.setUserId(rs.getInt(COLUMN_USER_ID));
		dto.setPerdiem(rs.getString(COLUMN_PERDIEM));
		dto.setPerdiemFrom(rs.getDate(COLUMN_PERDIEM_FROM));
		dto.setPerdiemTo(rs.getDate(COLUMN_PERDIEM_TO));
		dto.setCurrencyType(rs.getString(COLUMN_CURRENCY_TYPE));
	}

	/**
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(PerdiemMasterData dto) {}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * specified arbitrary SQL statement
	 */
	public PerdiemMasterData[] findByDynamicSelect(String sql, Object[] sqlParams) throws PerdiemMasterDataDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	/**
	 * Returns all rows from the PERDIEM_MASTER_DATA table that match the
	 * specified arbitrary SQL statement
	 */
	public PerdiemMasterData[] findByDynamicWhere(String sql, Object[] sqlParams) throws PerdiemMasterDataDaoException {
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			// bind parameters
			for (int i = 0; sqlParams != null && i < sqlParams.length; i++){
				stmt.setObject(i + 1, sqlParams[i]);
			}
			rs = stmt.executeQuery();
			// fetch the results
			return fetchMultiResults(rs);
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	public List<DepPerdiemReport> getPerdiemCurrencyMaps(Date start, Date end) throws PerdiemMasterDataDaoException, ParseException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		List<DepPerdiemReport> list = new ArrayList<DepPerdiemReport>();
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			//SQL.append("SELECT USER_ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , PERDIEM_TO," + ReconciliationModel.AUTO + " AS TYPE FROM PERDIEM_MASTER_DATA P JOIN USERS U ON U.ID=P.USER_ID WHERE U.STATUS=0 AND ( ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR PERDIEM_TO IS NULL) AND PERDIEM IS NOT NULL ");
			//for fixed perdiem
			//SQL.append(" UNION SELECT F.ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , PERDIEM_TO," + ReconciliationModel.FIXED + " AS TYPE FROM FIXED_PERDIEM F JOIN USERS U ON U.ID=F.ID WHERE U.STATUS=0 AND ( ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR PERDIEM_TO IS NULL) AND PERDIEM IS NOT NULL");
			//for seperated users perdiem
			//SQL.append(" UNION SELECT USER_ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , (CASE WHEN PERDIEM_TO < DATE_OF_SEPERATION THEN PERDIEM_TO ELSE DATE_OF_SEPERATION END) AS PERDIEM_TO," + ReconciliationModel.AUTO
			//	+ " AS TYPE FROM PERDIEM_MASTER_DATA P JOIN USERS U ON U.ID=P.USER_ID AND U.STATUS=2 JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID WHERE DATE_OF_SEPERATION BETWEEN ? AND ? AND ( ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR ? BETWEEN PERDIEM_FROM AND PERDIEM_TO OR PERDIEM_TO IS NULL) AND PERDIEM IS NOT NULL");
			// commented on 26th sep 2013
			/*String SQL = "SELECT USER_ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , (CASE WHEN DATE_OF_SEPERATION IS NULL THEN PERDIEM_TO WHEN PERDIEM_TO < DATE_OF_SEPERATION THEN PERDIEM_TO ELSE DATE_OF_SEPERATION END) AS PERDIEM_TO," + ReconciliationModel.AUTO
					+ " AS TYPE FROM PERDIEM_MASTER_DATA P JOIN USERS U ON U.ID=P.USER_ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID WHERE (DATE_OF_SEPERATION IS NULL OR DATE_OF_SEPERATION BETWEEN ? AND ? OR DATE_OF_SEPERATION > ?) AND ( PERDIEM_FROM BETWEEN ? AND ? OR PERDIEM_TO BETWEEN ? AND ? OR PERDIEM_TO IS NULL OR (PERDIEM_TO > ? AND PERDIEM_FROM < ?)) AND PERDIEM IS NOT NULL";
			*/
			String SQL = "SELECT USER_ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , (CASE WHEN DATE_OF_SEPERATION IS NULL THEN PERDIEM_TO WHEN PERDIEM_TO < DATE_OF_SEPERATION THEN PERDIEM_TO ELSE DATE_OF_SEPERATION END) AS PERDIEM_TO," + ReconciliationModel.AUTO
					+ " AS TYPE, SALARY_CYCLE FROM PERDIEM_MASTER_DATA P JOIN USERS U ON U.ID=P.USER_ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID JOIN FINANCE_INFO FI ON FI.ID = U.FINANCE_ID"
					+ " WHERE (DATE_OF_SEPERATION IS NULL OR DATE_OF_SEPERATION BETWEEN ? AND ? OR DATE_OF_SEPERATION > ?) AND (PERDIEM_TO IS NULL OR (PERDIEM_TO > ? AND PERDIEM_FROM < ?)) AND PERDIEM IS NOT NULL AND U.EMP_ID>0";
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			//SEESESEEE
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, start);
			stmt.setObject(2, end);
			stmt.setObject(3, end);
			stmt.setObject(4, start);
			stmt.setObject(5, end);
			/*stmt.setObject(6, start);
			stmt.setObject(7, end);
			stmt.setObject(8, end);
			stmt.setObject(9, end);*/
			rs = stmt.executeQuery();
			// fetch the results
			list = populatePerdiemDetails(rs, start, end);
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			SQL = "SELECT F.ID, PERDIEM, CURRENCY_TYPE , PERDIEM_FROM , (CASE WHEN DATE_OF_SEPERATION IS NULL THEN PERDIEM_TO WHEN PERDIEM_TO < DATE_OF_SEPERATION THEN PERDIEM_TO ELSE DATE_OF_SEPERATION END) AS PERDIEM_TO," + ReconciliationModel.FIXED
					+ " AS TYPE,SALARY_CYCLE FROM FIXED_PERDIEM F JOIN USERS U ON U.ID=F.ID JOIN PROFILE_INFO PF ON PF.ID=U.PROFILE_ID JOIN FINANCE_INFO FI ON FI.ID = U.FINANCE_ID"
					+ " WHERE (DATE_OF_SEPERATION IS NULL OR DATE_OF_SEPERATION BETWEEN ? AND ? OR DATE_OF_SEPERATION > ?) AND (PERDIEM_TO IS NULL OR (PERDIEM_TO > ? AND PERDIEM_FROM < ?)) AND PERDIEM IS NOT NULL AND U.EMP_ID>0";
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, start);
			stmt.setObject(2, end);
			stmt.setObject(3, end);
			stmt.setObject(4, start);
			stmt.setObject(5, end);
			/*stmt.setObject(6, start);
			stmt.setObject(7, end);
			stmt.setObject(8, end);
			stmt.setObject(9, end);*/
			rs = stmt.executeQuery();
			// fetch the results
			list.addAll(populatePerdiemDetails(rs, start, end));
			list.addAll(getPerdiemDetailsFromRollOn(start, end));
			return list;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}

	private List<DepPerdiemReport> populatePerdiemDetails(ResultSet rs, Date start, Date end) throws SQLException {
		List<DepPerdiemReport> list = new ArrayList<DepPerdiemReport>();
		while (rs.next()){
			try{
				
				java.sql.Date perdiemFrom = rs.getDate(4);
				java.sql.Date perdiemTo = rs.getDate(5);
				int perdiemAmount=0;
				int currency=0;
				if(rs.getString(3)!=null){
					currency=Integer.parseInt(rs.getString(3));
				}else currency=1;
				Calendar startcal = Calendar.getInstance();
				startcal.setTime(start);
				Calendar endcal = Calendar.getInstance();
				endcal.setTime(end);
				if (perdiemTo != null && perdiemTo.before(start)) continue;
				if (perdiemFrom != null && perdiemFrom.after(start)){
					startcal.setTime(perdiemFrom);
				}
				if (perdiemTo != null && perdiemTo.before(end)) endcal.setTime(perdiemTo);
				
				int startDate = startcal.get(Calendar.DAY_OF_MONTH);
				int endDate = endcal.get(Calendar.DAY_OF_MONTH);
				int noofdays = startcal.getActualMaximum(Calendar.DAY_OF_MONTH);
				int totaldays = 0;
				
				if(noofdays == 31)
				{
					totaldays = startDate + endDate ;
				}
				else if(noofdays == 30)
				{
					totaldays = (startDate + endDate) - 1;
				}
				else
				{
					totaldays = noofdays;
				}
				Calendar calendar = Calendar.getInstance();
				int currentMonth = (calendar.get(Calendar.MONTH) + 1);// 11
				int previousMonth = (calendar.get(Calendar.MONTH));// 10
				int currentYear = Calendar.getInstance().get(Calendar.YEAR);// 2017
				String previousThirdCycle = currentYear + "-" + previousMonth + "-" + 3;// 26-end
																						// of
																						// month
				String currentFirstCycle = currentYear + "-" + currentMonth + "-" + 1;// 1-12
				String prevousSecondCycle = currentYear + "-" + previousMonth + "-" + 2;// 13-24
				float lwpvalue = 0;
				int userId = rs.getInt(1);
				LeaveLwpDao leaveLwpDao = LeaveLwpDaoFactory.create();
				LeaveLwp[] lp = leaveLwpDao.findByDynamicSelect(
						"SELECT * FROM LEAVE_LWP WHERE USER_ID = ? AND( MONTH_CYCLE =? OR MONTH_CYCLE = ? OR MONTH_CYCLE = ?) ",
						new Object[] { userId, previousThirdCycle, currentFirstCycle, prevousSecondCycle });
				if (lp.length <= 0 || lp[0] == null) {
					int a = totaldays;
					totaldays = a;

				}

				else {

					for (LeaveLwp leaveLwp : lp) {

						lwpvalue += leaveLwp.getLwp(); // getting total LWP
														// based on cycle
						totaldays = (int) (totaldays - lwpvalue);

					}
				}
				//System.out.println("Per diem from  :::: " + startcal.getTime());
				//System.out.println("Per diem to ::: " + endcal.getTime());
				//System.out.println("Perdiem Amount ::: "+ DesEncrypterDecrypter.getInstance().decrypt(rs.getString(2)));
				//System.out.println("Total Payable days :::: "+totaldays);
				//list.add(new DepPerdiemReport(rs.getInt(1), endcal.get(Calendar.DAY_OF_MONTH) - startcal.get(Calendar.DAY_OF_MONTH) + 1, DesEncrypterDecrypter.getInstance().decrypt(rs.getString(2)),currency , rs.getShort(6), startcal.getTime(), endcal.getTime()));
				list.add(new DepPerdiemReport(rs.getInt(1), totaldays, DesEncrypterDecrypter.getInstance().decrypt(rs.getString(2)),currency , rs.getShort(6), startcal.getTime(), endcal.getTime(),rs.getString(7),lwpvalue));
			} catch (Exception e){
				e.printStackTrace();
				logger.error("unable to get perdiem data from db", e);
			}
		}
		return list;
	}

	/*private static Date getLastDateOfMonth(int year, int month) {
		if (month > 0){
			month--;
		}
		Calendar calendar = new GregorianCalendar(year, month, Calendar.DAY_OF_MONTH);
		calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH));
		return calendar.getTime();
	}*/
	private Collection<? extends DepPerdiemReport> getPerdiemDetailsFromRollOn(/*List<Integer> oldPerdiemData,*/Date start, Date end) throws PerdiemMasterDataDaoException {
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		List<DepPerdiemReport> list = new ArrayList<DepPerdiemReport>();
		try{
			// get the user-specified connection or get a connection from the
			// ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
			// construct the SQL statement
			final String SQL = "SELECT R.EMP_ID, R.PERDIEM, R.CURRENCY , R.START_DATE , CASE WHEN R.END_DATE IS NULL THEN DATE(R.ROLL_OFF_DATE) ELSE R.END_DATE END AS END_DATE, R.ID,F.SALARY_CYCLE FROM ROLL_ON R Left Join USERS U on U.ID=R.EMP_ID LEFT JOIN FINANCE_INFO F ON F.ID=U.FINANCE_ID WHERE R.PERDIEM IS NOT NULL AND CAST(R.PERDIEM AS SIGNED)>0 AND R.CURRENT!=1 AND (DATE(R.ROLL_OFF_DATE) >= ? AND DATE(R.ROLL_OFF_DATE) <=?)";

/*			SELECT 
    R.EMP_ID,
    R.PERDIEM,
    R.CURRENCY,
    R.START_DATE,
    CASE
        WHEN R.END_DATE IS NULL THEN DATE(R.ROLL_OFF_DATE)
        ELSE R.END_DATE
    END AS END_DATE,
    R.ID,
    f.SALARY_CYCLE
FROM
    ROLL_ON R left join USERS u on u.id=R.EMP_ID 
left join FINANCE_INFO f on f.ID=u.FINANCE_ID
WHERE
    R.PERDIEM IS NOT NULL
        AND CAST(R.PERDIEM AS SIGNED) > 0
        AND R.CURRENT != 1
        AND (DATE(R.ROLL_OFF_DATE) >= '2017-02-16 00:00:00'
        AND DATE(R.ROLL_OFF_DATE) <= '2017-03-15 00:00:00')*/
			
			//	final String SQL = "SELECT EMP_ID, PERDIEM, CURRENCY , START_DATE , CASE WHEN END_DATE IS NULL THEN DATE(ROLL_OFF_DATE) ELSE END_DATE END AS END_DATE, R.ID FROM ROLL_ON R WHERE PERDIEM IS NOT NULL AND CAST(PERDIEM AS SIGNED)>0 AND CURRENT!=1 AND (DATE(ROLL_OFF_DATE) >= ? AND DATE(ROLL_OFF_DATE) <=?)";
			if (logger.isDebugEnabled()){
				logger.debug("Executing " + SQL);
			}
			// prepare statement
			stmt = conn.prepareStatement(SQL);
			stmt.setMaxRows(maxRows);
			stmt.setObject(1, start);
			stmt.setObject(2, end);
			rs = stmt.executeQuery();
			// fetch the results
			Map<String, Integer> currMap = new HashMap<String, Integer>();
			while (rs.next()){
				try{
					java.sql.Date perdiemFrom = rs.getDate(4);
					java.sql.Date perdiemTo = rs.getDate(5);
					Calendar startcal = Calendar.getInstance();
					startcal.setTime(start);
					Calendar endcal = Calendar.getInstance();
					endcal.setTime(end);
					int userId = rs.getInt(1);
					if (perdiemTo != null && perdiemTo.before(start)) continue;
					if (perdiemFrom != null && perdiemFrom.after(start)){
						startcal.setTime(perdiemFrom);
					}
					if (perdiemTo != null && perdiemTo.before(end)) endcal.setTime(perdiemTo);
					Client[] clients = ClientDaoFactory.create(conn).findByDynamicSelect("SELECT C.* FROM CLIENT C JOIN PROJ_CLIENT_MAP PCM ON PCM.CLIENT_ID= C.ID JOIN ROLL_ON_PROJ_MAP R ON PCM.PROJ_ID = R.PROJ_ID WHERE R.ROLL_ON_ID=? LIMIT 0,1", new Object[] { rs.getInt(6) });
					String client;
					if (clients != null && clients.length > 0){
						client = clients[0].getName();
					} else{
						client = "N.A";
						logger.error("perdiem report : report generation : userid =" + userId + ", was not associated with any client");
					}
					String currencyName = rs.getString(3);
					int currency = 1;
					if (currencyName != null && !currencyName.equals("INR")){
						if (currMap.containsKey(currencyName)) currency = currMap.get(currencyName).intValue();
						else{
							Currency currencyRecords[] = CurrencyDaoFactory.create(conn).findWhereAbbrevationEquals(currencyName);
							if (currencyRecords != null && currencyRecords.length > 0){
								currency = currencyRecords[0].getId();
							}
							currMap.put(currencyName, currency);
						}
					}
					int startDate = startcal.get(Calendar.DAY_OF_MONTH);
					int endDate = endcal.get(Calendar.DAY_OF_MONTH);
					int noofdays = startcal.getActualMaximum(Calendar.DAY_OF_MONTH);
					int totaldays = 0;
					if(noofdays == 31){
						totaldays = startDate + endDate ;
					}else if(noofdays == 30){
						totaldays = (startDate + endDate) - 1;
					}else{
						totaldays = noofdays;
					}
					Calendar calendar = Calendar.getInstance();
					int currentMonth = (calendar.get(Calendar.MONTH) + 1);// 11
					int previousMonth = (calendar.get(Calendar.MONTH));// 10
					int currentYear = Calendar.getInstance().get(Calendar.YEAR);// 2017
					String previousThirdCycle = currentYear + "-" + previousMonth + "-" + 3;//26-end of month
					String currentFirstCycle = currentYear + "-" + currentMonth + "-" + 1;//1-12
					String prevousSecondCycle = currentYear + "-" + previousMonth + "-" + 2;//13-24
					float lwpvalue = 0;
					int userIdRollon = rs.getInt(1);
					LeaveLwpDao leaveLwpDao = LeaveLwpDaoFactory.create();
					LeaveLwp[] lp = leaveLwpDao.findByDynamicSelect(
							"SELECT * FROM LEAVE_LWP WHERE USER_ID = ? AND( MONTH_CYCLE =? OR MONTH_CYCLE = ? OR MONTH_CYCLE = ?) ",
							new Object[] { userIdRollon, previousThirdCycle, currentFirstCycle, prevousSecondCycle });
					if (lp.length <= 0 || lp[0] == null) {
						int a = totaldays;
						totaldays=a;
						
					} 
					
					
					else {

						for (LeaveLwp leaveLwp : lp) {

							lwpvalue += leaveLwp.getLwp(); // getting total LWP based on cycle
							totaldays=(int) (totaldays-lwpvalue);

						}
					}
					
					
					//list.add(new DepPerdiemReport(userId, endcal.get(Calendar.DAY_OF_MONTH) - startcal.get(Calendar.DAY_OF_MONTH) + 1, rs.getString(2), currency, ReconciliationModel.AUTO, startcal.getTime(), endcal.getTime(), client));
					list.add(new DepPerdiemReport(userId, totaldays, rs.getString(2), currency, ReconciliationModel.AUTO, startcal.getTime(), endcal.getTime(), rs.getString(7),lwpvalue));
				} catch (Exception e){
					logger.error("unable to get perdiem data from db", e);
				}
			}
			logger.info("Perdiem data based on Roll On :" + list);
			return list;
		} catch (Exception _e){
			logger.error("Exception: " + _e.getMessage(), _e);
			throw new PerdiemMasterDataDaoException("Exception: " + _e.getMessage(), _e);
		} finally{
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied){
				ResourceManager.close(conn);
			}
		}
	}
}